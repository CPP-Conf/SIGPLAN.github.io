<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta http-equiv="Content-Style-Type" content="text/css">
      <style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style>
      <title>SPLASH Companion 2021: Companion Proceedings of the 2021 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity</title>
   </head>
   <body>
      <div id="DLtoc">
         <div id="DLheader">
            <h1>SPLASH Companion 2021: Companion Proceedings of the 2021 ACM SIGPLAN International Conference on Systems,
               Programming, Languages, and Applications: Software for Humanity</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3484271"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
               Full Citation in the ACM Digital Library
               </a></div>
         <div id="DLcontent">
            <h2>SESSION: Keynotes</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3490527">Integrated scientific modeling and lab automation (keynote)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Luca Cardelli</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>The cycle of observation, hypothesis formulation, experimentation, and falsification
                     that has driven scientific and technical progress is lately becoming automated in
                     all its separate components. However, integration between these automated components
                     is lacking. Theories are not placed in the same formal context as the (coded) protocols
                     that are supposed to test them: neither description knows about the other, although
                     they both aim to describe the same process. </p> 
                  <p> We develop integrated descriptions from which we can extract both the model of a
                     phenomenon (for possibly automated mathematical analysis), and the steps carried out
                     to test it (for automated execution by lab equipment). This is essential if we want
                     to carry out automated model synthesis, falsification, and inference, by taking into
                     account uncertainties in both the model structure and in the equipment tolerances
                     that may jointly affect the results of experiments.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3490528">Designing safe programmed molecular systems (keynote)</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Robyn Lutz</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Molecular programming uses the computational power of DNA and other biomolecules to
                     create nanoscale systems. Many of these will be safety-critical, such as bio-compatible
                     diagnostic sensors and targeted drug-delivery devices. Design of these programmed
                     molecular systems needs to assure safe outcomes from very many, very small, fault-prone
                     components operating simultaneously in a dynamic environment. Some of this can be
                     achieved by adapting existing software engineering methods, but molecular programming
                     also presents new challenges that will require new methods. This talk discusses an
                     example of such a challenge, describes how we design safety-critical building blocks,
                     and presents work in progress to ascertain how robust a molecular program is. Similar
                     approaches also will help design safe non-molecular systems with highly distributed,
                     autonomous, fault-prone components operating in dynamic environments.</p>
                  	</div>
            </div>
            						
            					
            <h2>SESSION: Graduate Papers</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484972">Can reactive synthesis and syntax-guided synthesis be friends?</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Wonhyuk Choi</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>While reactive synthesis and syntax-guided synthesis (SyGuS) have seen enormous progress
                     in recent years, combining the two approaches has remained a challenge. In this work,
                     we present the synthesis of reactive programs from Temporal Stream Logic modulo theories
                     (TSL-MT), a framework that unites the two approaches to synthesize a single program.
                     In our approach, reactive synthesis and SyGuS collaborate in the synthesis process,
                     and generate executable code that implements both reactive and data-level properties.
                     We also present a tool, temos, that combines state-of-the-art methods in reactive
                     synthesis and SyGuS to synthesize programs from TSL-MT specifications. We demonstrate
                     the applicability of our approach over a set of benchmarks, and present a deep case
                     study on synthesizing a music keyboard synthesizer.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484973">Run-time data analysis in dynamic runtimes</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Lukas Makor</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Databases are typically faster in processing huge amounts of data than applications
                     with hand-coded data access. Even though modern dynamic runtimes optimize applications
                     intensively, they cannot perform certain optimizations that are traditionally used
                     by database systems as they lack the required information. Thus, we propose to extend
                     the capabilities of dynamic runtimes to allow them to collect fine-grained information
                     of the processed data at run time and use it to perform database-like optimizations.
                     By doing so, we want to enable dynamic runtimes to significantly boost the performance
                     of data-processing workloads. Ideally, applications should be as fast as databases
                     in data-processing workloads. To show the feasibility of our approach, we are implementing
                     it in a polyglot dynamic runtime.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484974">Run-time data analysis to drive compiler optimizations</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Sebastian Kloibhofer</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Dynamic compilers collect a variety of information to optimize programs and achieve
                     peak performance. Nevertheless, particularly in data-heavy applications, analysis
                     of the processed data - data structures, metrics, relations - could enable additional
                     optimizations in terms of access patterns and data locality. Query planning in database
                     systems is one source of inspiration, but due to the required overhead to collect
                     such information, it is infeasible in dynamic compilers. With this project, we propose
                     integrating data analysis into a dynamic runtime to speed up big data applications.
                     The goal is to use the detailed run-time information for speculative compiler optimizations
                     based on the shape and complexion of the data to improve performance.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484975">A study of call graph effectiveness for framework-based web applications</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Madhurima Chakraborty</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Modern web applications are continuously evolving and becoming increasingly reliant
                     on web frameworks to support their ever-changing needs. This necessitates the realization
                     of efficient static analysis methodologies for the purpose of bug finding and security
                     auditing of such applications. Moreover, the majority of these frameworks are written
                     in JavaScript, which is difficult to analyze due to its extremely dynamic nature.
                     The primary goal of this work is to study the effectiveness of the present state-of-the-art
                     call graph approaches for JavaScript and propose techniques to enhance them such that
                     they discover more of the crucial functions and call edges in modern, framework-based
                     JavaScript applications. Ideally, these new techniques must enhance function and call
                     edge discovery without much impact on precision and scalability.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484976">Avoiding monomorphization bottlenecks with phase-based splitting</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Sophie Kaleba</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>State-of-the-art managed runtimes apply aggressive optimizations speculating that
                     programs have low variability. However, literature shows that program behavior may
                     evolve at run time and experience different execution <em>phases</em>. This variable behavior may hide optimization opportunities. Taking phases into account
                     may thus improve performance when applied to phase-sensitive optimizations such as
                     lookup caches, which can be monomorphization bottlenecks when they contain phase-specific
                     entries. </p> 
                  <p>In this project, we introduce <em>phase-based splitting</em>, an optimization that utilizes phases to guide monomorphization based on splitting.
                     Preliminary results on a first prototype and micro-benchmarks show promising speedups
                     ranging from 10 to 20% on average, peaking at 47.6% per phase. In our next steps,
                     we will evaluate our approach on a richer set of benchmarks and real-world applications,
                     and define heuristics to better guide phase-based splitting.</p>
                  	</div>
            </div>
            						
            					
            <h2>SESSION: Undergraduate Papers</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484977">Programming-by-example by programming-by-example: synthesis of looping programs</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Shmuel Berman</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Program synthesis has seen many new applications in recent years, in large part thanks
                     to the introduction of SyGuS. However, no existing SyGuS solvers have support for
                     synthesizing recursive functions. We introduce an multi-phase algorithm for the synthesis
                     of recursive "looplike" programs in SyGuS for programming-by-example. We solve constraints
                     individually and treat them as "unrolled" examples of how a recursive program would
                     behave, and solve for the generalized recursive solution. Our approach is modular
                     and supports any SyGuS Solver.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484978">Edgeworth: authoring diagrammatic math problems using program mutation</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Hwei-Shin Harriman</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Building connections between mathematical expressions and their visual representations
                     increases conceptual understanding and flexibility. However, students rarely practice
                     visualizing abstract mathematical relationships because developing diagrammatic problems
                     is challenging, especially at scale. To address this issue, we introduce Edgeworth,
                     a system that automatically generates correct and incorrect diagrams for a given question
                     prompt. It does so by mutating declarative mathematical statements with visual semantics.
                     We evaluated the system by recreating diagrammatic problems in a widely used geometry
                     textbook.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484979">Towards decidable and expressive DOT</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Sophia Roshal</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>While decidability of type systems may be a reasonable sacrifice to make in exchange
                     for greatly increased expressivity in some cases, having a type checker that is guaranteed
                     to terminate while maintaining a high degree of expressivity can be beneficial. Over
                     the last few years there have been several papers and theses written describing decidable
                     variants of DOT, however, these variants all present similar challenges in limitations
                     on expressivity. We aim to increase the expressivity of these variants without sacrificing
                     decidability.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484980">Implementation of an end-to-end gradual verification system</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Hemant Gouni</li>
               <li class="nameList Last">Conrad Zimmerman</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Static verification is used to ensure the correctness of programs. While useful in
                     critical applications, the high overhead associated with writing specifications limits
                     its general applicability. Similarly, the run-time costs introduced by dynamic verification
                     limit its practicality. Gradual verification validates partially specified code statically
                     where possible and dynamically where necessary. As a result, software developers gain
                     granular control over the trade-offs between static and dynamic verification. This
                     paper contains an end-to-end presentation of gradual verification in action, with
                     a focus on applying it to <em>C</em><sub>0</sub> (a safe subset of C) and implementing the required dynamic verification.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3484271.3484981">Source code authorship attribution using file embeddings</a></h3>
            <ul class="DLauthors">
               <li class="nameList Last">Alina Bogdanova</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>The problem of source code authorship attribution is crucial for a few reasons. Security
                     and legal issues are the most popular ones. However, this domain could also help to
                     understand the nature of the personal code style. This type of information could be
                     used, for instance, by IDEs to improve the developer's experience of writing the code.
                     The goal of this study is to construct an interpretable model for source code embeddings
                     generation. Such embeddings should represent the correspondence between the source
                     code and its author.</p>
                  	</div>
            </div>
            						
            					</div>
      </div>
   </body>
</html>
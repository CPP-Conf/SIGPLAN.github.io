<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta http-equiv="Content-Style-Type" content="text/css">
      <style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style>
      <title>DLS 2021: Proceedings of the 17th ACM SIGPLAN International Symposium on Dynamic Languages</title>
   </head>
   <body>
      <div id="DLtoc">
         <div id="DLheader">
            <h1>DLS 2021: Proceedings of the 17th ACM SIGPLAN International Symposium on Dynamic Languages</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3486602"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
               Full Citation in the ACM Digital Library
               </a></div>
         <div id="DLcontent">
            <h2>SESSION: Papers</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3486602.3486767">Union and intersection contracts are hard, actually</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Teodoro Freund</li>
               <li class="nameList">Yann Hamdaoui</li>
               <li class="nameList Last">Arnaud Spiwack</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Union and intersection types are a staple of gradually typed languages such as TypeScript.
                     While it's long been recognized that union and intersection types are difficult to
                     verify statically, it may appear at first that the dynamic part of gradual typing
                     is actually pretty simple. </p> 
                  <p> It turns out however, that in presence of higher-order contracts union and intersection
                     are deceptively difficult. The literature on higher-order contracts with union and
                     intersection, while keenly aware of the fact, doesn't really explain why. We point
                     and illustrate the problems and trade-offs inherent to union and intersection contracts,
                     via example and a survey of the literature.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3486602.3486768">First-class environments in R</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Aviral Goel</li>
               <li class="nameList Last">Jan Vitek</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>The R programming language is widely used for statistical computing. To enable interactive
                     data exploration and rapid prototyping, R encourages a dynamic programming style.
                     This programming style is supported by features such as first-class environments.
                     Amongst widely used languages, R has the richest interface for programmatically manipulating
                     environments. With the flexibility afforded by reflective operations on first-class
                     environments, come significant challenges for reasoning and optimizing user-defined
                     code. This paper documents the reflective interface used to operate over first-class
                     environment. We explain the rationale behind its design and conduct a large-scale
                     study of how the interface is used in popular libraries.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3486602.3486769">Analyzing permission transfer channels for dynamically typed languages</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Théo Rogliano</li>
               <li class="nameList">Guillermo Polito</li>
               <li class="nameList">Luc Fabresse</li>
               <li class="nameList Last">Stéphane Ducasse</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Communicating Sequential Process&nbsp;(CSP) is nowadays a popular concurrency model in
                     which threads/processes communicate by exchanging data through channels. Channels
                     help in orchestrating concurrent processes but do not solve per-se <em>data races</em>. To prevent data races in the channel model, many programming languages rely on type
                     systems to express ownership and behavioural restrictions such as immutability. However,
                     dynamically-typed languages require run-time mechanisms because of the lack of type
                     information at compile-time. </p> 
                  <p>In this paper, we propose to augment channels with four different permission transfer
                     semantics. We explore two mechanisms to implement such permission transfers at run
                     time: write barriers and partial-read barriers. To validate our approach we implemented
                     a channel framework in Pharo, and we extended it with different permission transfer
                     semantics. We report on performance measurements of both (a) the transfer overhead
                     on a single object and on a graph of objects, and (b) the per-object access overhead
                     incurred by ownership checks. This work stands as a cornerstone of future work on
                     adaptive optimizations for permission transfer channels.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3486602.3486930">CompGen: generation of fast JIT compilers in a multi-language VM</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Florian Latifi</li>
               <li class="nameList">David Leopoldseder</li>
               <li class="nameList">Christian Wimmer</li>
               <li class="nameList Last">Hanspeter Mössenböck</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>The first Futamura projection enables compilation and high performance code generation
                     of user programs by partial evaluation of language interpreters. Previous work has
                     shown that online partial evaluation can yield the same peak performance as a specialized
                     JIT compiler. However, this comes with the downside of additional compile time: Online
                     partial evaluation of language interpreters has to specialize interpreter code on
                     the fly to the dynamic types used at run time to create efficient target code. As
                     a result, the time spent on partial evaluation itself is a significant contributor
                     to the overall compile time of a method. </p> 
                  <p>The second Futamura projection solves this problem by self-applying partial evaluation
                     on the partial evaluation algorithm, effectively generating language-specific compilers
                     from interpreters. This typically reduces compilation time compared to the first projection.
                     Previous work employed the second projection to some extent, however we are not aware
                     of any usage of the generic second Futamura projection in a state-of-the-art language
                     runtime. </p> 
                  <p>To solve the problems of self-application and code-size explosion, this paper proposes
                     <em>CompGen</em>, an approach based on code generation of subsets of language interpreters. It is
                     loosely based upon the idea of the second Futamura projection. Our implementation
                     of CompGen for GraalVM shows that our usage of a novel code-generation algorithm allows
                     us to generate efficient compilers that emit fast target programs which easily outperform
                     the first Futamura projection in compilation time. We evaluated our approach with
                     the high-performance JavaScript implementation of GraalVM and standard JavaScript
                     benchmarks, showing that our approach achieves &gt;2<em>X</em> speedups of partial evaluation.</p>
                  	</div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3486602.3486931">Runtime and compiler support for HAMTs</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Sona Torosyan</li>
               <li class="nameList">Jon Zeppieri</li>
               <li class="nameList Last">Matthew Flatt</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Many functional languages---including Racket, Clojure, and Scala---provide a persistent-map
                     datatype with an implementation based on Hash Array Mapped Tries (HAMTs). HAMTs enable
                     efficient functional lookup, insertion, and deletion operations with a small memory
                     footprint, especially when taking advantage of implementation techniques that have
                     been developed since the original HAMT implementation. Racket's latest HAMT implementation
                     is based on an intermediate data structure, a stencil vector, that supports an especially
                     compact representation of HAMTs with help from the compiler and memory manager. That
                     is, stencil vectors provide an abstraction to improve HAMT performance without burdening
                     the compiler with all of the complexity and design choices of a HAMT implementation.
                     Benchmark measurements show that HAMTs in Racket have performance comparable to other
                     state-of-the-art implementations, while stencil-vector HAMTs are more compact and
                     run as fast as alternative representations in Racket. Although we only report on Racket,
                     our experience suggests that a stencil-vector datatype in other dynamic-language implementations
                     might improve HAMT performance in those implementations.</p>
                  	</div>
            </div>
            						
            					</div>
      </div>
   </body>
</html>
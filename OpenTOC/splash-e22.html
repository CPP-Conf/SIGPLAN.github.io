<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>SPLASH-E 2022: Proceedings of the 2022 ACM SIGPLAN International Symposium on SPLASH-E</title></head><body><div id="DLtoc"><div id="DLheader"><h1>SPLASH-E 2022: Proceedings of the 2022 ACM SIGPLAN International Symposium on SPLASH-E</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3563767"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568126">Codehound: Helping Instructors Track Pedagogical Code Dependencies in Course Materials</a></h3><ul class="DLauthors"><li class="nameList">Sam Lau</li><li class="nameList Last">Philip J. Guo</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Instructors of programming courses must manage a variety of pedagogical dependencies in their teaching materials. For instance, updating the code used in a single lesson can require cascading changes to other lessons in the course. Currently, they must manually maintain these dependencies across many files, which is tedious and error-prone. To help instructors track pedagogical code dependencies, we created a system called Codehound that uses static analysis to automatically detect where functions are introduced and reused through an entire course. To show how Codehound can be used, we present three usage scenarios inspired by our own experiences teaching large data science courses. These scenarios demonstrate how Codehound can help instructors create new content, collaborate with staff to refactor existing content, and estimate the cost of future course changes.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568125">The Role of Abstraction in Introductory Programming</a></h3><ul class="DLauthors"><li class="nameList">Kezia Devathasan</li><li class="nameList">Celina Berg</li><li class="nameList Last">Daniela Damian</li></ul><div class="DLabstract"><div style="display:inline">
				<p>First year computer science (CS) courses have mean failure rates as high as 30.3% [13]. In an attempt to identify and mitigate potential contributing factors to this problem, this study aims to investigate how the understanding of abstraction impacts students’ programming ability and subsequent success in a first-year data structures course. Specifically, we employ the use of videos to explicitly introduce the concept of abstraction and assess understanding through quizzes directly related to concrete programming exercises. Our work is motivated and guided by related work on abstract thinking as it relates to the skillset of a computer scientist, in addition to existing work on the introduction of abstraction as a learning outcome in computer science education. We measure the students’ understanding of abstraction through a series of short weekly quizzes tightly tied to graded programming exercises. Through our analysis we identify specific topics in the introductory CS course that present abstraction difficulties for students, and suggest potential reasons that these topics are particularly challenging. We also evaluate the students’ learning experience when taught abstraction explicitly, discussing both successes and areas in need of improvement. Finally, we recommend introducing abstraction into the early CS curriculum as an explicit learning outcome and treating the topic as a persistent theme throughout courses in order to support students’ understanding of foundational programming.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568128">Crossing Learning Thresholds Progressively via Active Learning</a></h3><ul class="DLauthors"><li class="nameList">Sarnath Ramnath</li><li class="nameList Last">Brahma Dathan</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Existence of thresholds in learning has been long recognized. Their nature has been well characterized, and it is recognized that they need to be treated differently from other core concepts.  
Helping learners cross thresholds has been identified as one of the challenges of course and curriculum design, and best practices for integrating thresholds into the classroom via active learning have been identified. Threshold concepts have been recognized to exist in computing education as well. In this paper we examine two difficult concepts in software development: model selection and substitutability. By treating them as threshold concepts and applying the recommended practices, we have succeeded in spiraling them into a course, with suitable scaffolds, over a period of several weeks. In the course of doing this, we developed examples that enable students to find relevance through a broader view of substitutability, and also developed a novel approach to writing requirements that helped students understand why FSM models are preferred in some situations.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568132">Evaluating the Quality of Student-Written Software Tests with Curated Mutation Analysis</a></h3><ul class="DLauthors"><li class="nameList">Braxton Hall</li><li class="nameList Last">Elisa Baniassad</li></ul><div class="DLabstract"><div style="display:inline">
				<p>An important learning outcome in software engineering education is the ability to write an effective test suite that rigorously tests a target application. The standard approach for assessing test suites is to check coverage which can be problematic because coverage rewards code invocation, without checking test assertion correctness. </p><p>Mutation Analysis (injecting a small fault into a clone of a codebase) has been used in both industry and academia to check test suite quality. A mutant is <em>killed</em> if any tests in the test suite fail on the clone. More mutants killed indicates a stronger suite, as it is more sensitive to defects. Mutation Analysis has been limited in an educational setting because of the prohibitive cost in both time and compute power to run the students’ suites over all generated clones. </p><p>We employed Mutation Analysis to assess test suite quality in our upper-year Software Engineering course at a large research intensive university. This paper makes two contributions: (1) We show that it is feasible and effective to use a small sample of hand-written mutants for grading, and (2) We assess effectiveness for promoting student learning by comparing students graded with coverage to those graded with Mutation Analysis. </p><p>We found that mutation graded students write more correct tests, check more of the behaviour of invoked code, and more actively seek to understand the project specification.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568130">Data Science Pedagogy to Support Industry, Governmental, and Research Initiatives</a></h3><ul class="DLauthors"><li class="nameList">Kevin Dick</li><li class="nameList">Hoda Khalil</li><li class="nameList Last">Gabriel A. Wainer</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Data Science practices are increasingly leveraged in disparate domains of research, whether as part of industry workflows, governmental department initiatives, or open problems within academic communities. Herein, we describe designing term-projects to introduce senior undergraduate students to applied Data Science research for industry, governmental, or academic "clients" through a series of course assignments and client meetings. We outline the lessons learned and describe how they may be adapted within similar courses. Students are familiarized with data science best practices, obtain applied research experience, and (potentially) professionally benefit from an actual research contribution in the form of a peer-reviewed conference publication; at time of writing, we have published three student-led projects in the proceedings of eminent peer-reviewed conferences. We highly recommend introducing undergraduate students to such client-serving research applications early in their program to encourage them to consider pursuing a research-focused career path.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568131">Expressions in Java: Essential, Prevalent, Neglected?</a></h3><ul class="DLauthors"><li class="nameList">Luca Chiodini</li><li class="nameList">Igor Moreno Santos</li><li class="nameList Last">Matthias Hauswirth</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Expressions are the building blocks of formal languages such as lambda calculus as well as of programming languages that are closely modeled after it. Although expressions are also an important part of programs in languages like Java, that are not primarily functional, teaching practices typically don’t focus as much on expressions.  
</p>
<p>
We conduct both a theoretical analysis of the Java language, as well as an empirical analysis of the use of expressions in Java programs by novices, to understand the role expressions play in writing programs. We then proceed by systematically analyzing teaching materials for Java to characterize how they present expressions.  
</p>
<p>
Our findings show that expressions are an essential construct in Java, that they are prevalent in student code, but that current textbooks do not introduce expressions as the central, general, and compositional concept they are.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568133">Team Harmony before, during, and after COVID-19</a></h3><ul class="DLauthors"><li class="nameList">Noa Heyl</li><li class="nameList">Elisa Baniassad</li><li class="nameList Last">Oluwakemi Ola</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Teamwork is integral to any computer science curriculum because it provides students with experiences that mirror the industry. Some students are resistant to working in teams because of the perceived inequities. Assessing individual participation and team dynamics can provide faculty with valuable information to design and deploy interventions to improve students’ teamwork skills and help dysfunctional teams. </p><p>This work looks at the <em>team harmony</em> experience of pairs in a large (300 person) third-year Software Engineering class in a North American research-intensive university. For the last seven semesters, we asked students to regularly report their sense of equity relating to their contributions to group discussions, influence over task assignments, and overall contributions to their course project development. </p><p>Based on our analyses, four periods emerged: prior to COVID-19, during the transitional period as restrictions were applied due to the pandemic, during COVID-19, and after the acute COVID-19 period ended and restrictions were lifted. Overall, we saw that students experienced a decrease in team harmony during the transition to lockdown and that harmony recovered in subsequent semesters, with some measures gradually trending worse over time in the post-pandemic period (once the restrictions were lifted).</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563767.3568127">Mio: A Block-Based Environment for Program Design</a></h3><ul class="DLauthors"><li class="nameList">Junya Nose</li><li class="nameList">Youyou Cong</li><li class="nameList Last">Hidehiko Masuhara</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Program design should be taught with a comprehensible guideline and  
appropriate tool support. 
While Felleisen et al.'s program design recipe serves as a good guideline  
for novice learners, no existing tool provides sufficient support for  
step-by-step design. 
We propose Mio, an environment for designing programs based on the design 
recipe. 
In Mio, the programmer uses blocks to express design artifacts, such as  
examples of input and output data. 
The system checks the consistency of the design, gives feedback to the  
programmer, and produces a half-completed program for use in steps after  
designing. 
A preliminary experiment in the classroom showed its ability to make  
program design easier for novices, and to encourage programmers to follow  
the design recipe. 
In this paper, we demonstrate the core features of Mio, report the results  
of the experiment, and discuss our plans for extensions.</p>
			</div></div>
							
						</div></div></body></html>
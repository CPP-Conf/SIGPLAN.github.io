
<!doctype html>
<head>
<META http-equiv="Content-Style-Type" content="text/css">
<title>REBLS 2018- Proceedings of the 5th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems</title>
<STYLE type="text/css">
#DLtoc {
	font: normal 12px/1.5em Arial, Helvetica, sans-serif;
	}

#DLheader {
	}
#DLheader h1 {
	font-size:16px;	
}
	
#DLcontent {
	 font-size:12px;
	}
#DLcontent h2 {
	 font-size:14px;
	 margin-bottom:5px;
	}
#DLcontent h3 {
	 font-size:12px;
	 padding-left:20px;
	 margin-bottom:0px;
	}

#DLcontent ul{
	margin-top:0px;
	margin-bottom:0px;
	}
		
.DLauthors li{
	display: inline;
	list-style-type: none;
	padding-right: 5px;
	}
	
.DLauthors li:after{
	content:",";
	}
.DLauthors li.nameList.Last:after{
	content:"";
	}		

.DLabstract {
	 padding-left:40px;
	 padding-right:20px;
	 display:block;
	}

.DLformats li{
	display: inline;
	list-style-type: none;
	padding-right: 5px;
	}
	
.DLformats li:after{
	content:",";
	}
.DLformats li.formatList.Last:after{
	content:"";
	}		

.DLlogo {
	vertical-align:middle; 
	padding-right:5px;
	border:none;
	}
	
.DLcitLink {
	margin-left:20px;
	}	

.DLtitleLink {
	margin-left:20px;
	}	

.DLotherLink {
	margin-left:0px;
	}		
   
</STYLE>
</head>
<body>
<div id="DLtoc">
<div id="DLheader">
<h1>REBLS 2018- Proceedings of the 5th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems</h1>
<a class="DLcitLink" href="https://dl.acm.org/citation.cfm?id=3281278" title="Go to the ACM Digital Library for additional information about this proceeding"><img class="DLlogo" src="https://dl.acm.org/img/dllogo.png" alt="Digital Library logo" height="30" width="30">Full Citation in the ACM Digital Library</a>
</div>
<div id="DLcontent">
<h2>SESSION: Embedded Systems and IoT</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N661829" title="Get the Full Text from the ACM Digital Library">Synthesizing manually verifiable code for statecharts</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Steven Smyth</li>
<li class="nameList">Christian Motika</li>
<li class="nameList Last">Reinhard von Hanxleden</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Statecharts are an established mechanism to model reactive, state-oriented behavior of embedded systems. We here present an approach to automatically generate code from statecharts, with a particular focus on readability and ease of matching the generated code with the original model. This not only saves programming effort and reduces the error rate compared to manual coding, but it also facilitates the task of verifying that the code does what it is supposed to do. We have implemented this approach for the SCCharts language in an open-source framework. A user study confirmed that the generated code tends to be more readable than code from other code generators.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N661820" title="Get the Full Text from the ACM Digital Library">RHEA: a reactive, heterogeneous, extensible, and abstract framework for dataflow programming</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Orestis Melkonian</li>
<li class="nameList Last">Angelos Charalambidis</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Robotics and IoT applications are perfect candidates that can benefit from the functional reactive programming paradigm. Moreover, since a typical program can be represented as a dataflow graph, the application can be conceptually separated and distributed in different machines and the several graph partitions can run in parallel and possibly in different execution stacks. In this paper we propose a general-purpose reactive framework that can express complex applications, seamlessly and transparently integrating different sources and middlewares. The framework is abstract and extensible, making it easy to integrate with well-established technologies that rely on the PubSub model. We demonstrate the usability of the framework by providing application examples in the domain of robotics and IoT.</p></div> </div>
<h2>SESSION: Multitier and Distributed Computing</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N661821" title="Get the Full Text from the ACM Digital Library">Reactive chatbot programming</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Guillaume Baudart</li>
<li class="nameList">Martin Hirzel</li>
<li class="nameList">Louis Mandel</li>
<li class="nameList">Avraham Shinnar</li>
<li class="nameList Last">J&#233;r&#244;me Sim&#233;on</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Chatbots are reactive applications with a conversational interface. They are usually implemented as compositions of client-side components and cloud-hosted services, including artificial-intelligence technology. Unfortunately, programming such reactive multi-tier applications with traditional programming languages is cumbersome. This paper introduces wcs-ocaml, a new multi-tier chatbot generator library designed for use with the reactive language ReactiveML. The paper explains our library with small didactic examples throughout, and closes with a larger case-study of a chatbot for authoring event-processing rules.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N661822" title="Get the Full Text from the ACM Digital Library">DISCOPAR: a visual reactive programming language for generating cloud-based participatory sensing platforms</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Jesse Zaman</li>
<li class="nameList">Kennedy Kambona</li>
<li class="nameList Last">Wolfgang De Meuter</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Participatory sensing (PS) platforms enable stakeholders to collect, analyse and visualise data for a particular interest. Despite high societal demand, developing a new PS platform remains a labour-intensive, nonreusable process that requires high technical expertise. We present DISCOPAR, a visual reactive flow-based domain-specific language geared towards the construction of reusable citizen observatories. With DISCOPAR, users interact with visual components to implement the various elements of a PS platforms without having to worry about its underlying technological complexities. We validate our approach through experiments using real-world empirical usability studies of ICT-agnostic users. The results show that DISCOPAR allows users with limited technological knowledge to create their own PS platform.</p></div> </div>

<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N661823" title="Get the Full Text from the ACM Digital Library">Skitter: a DSL for distributed reactive workflows</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Mathijs Saey</li>
<li class="nameList">Joeri De Koster</li>
<li class="nameList Last">Wolfgang De Meuter</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Writing real-time applications that react to vast amounts of incoming data is a hard problem, as the volume of incoming data implies the need for distributed execution on a cluster architecture. We envision such an application can be created as a data processing pipeline which consists of a set of generic, reactive components, which may be reused in other applications. However, there is currently no programming model or framework that enables the reactive, scalable execution of such a pipeline on a cluster architecture. Our work introduces the notion of <em>reactive workflows</em>, a technique that combines concepts from scientific workflows and reactive programming. Reactive workflows enable the integration of these generic components into a single workflow that can be executed on a cluster architecture in a reactive, scalable way. To deploy these reactive workflows, we introduce a domain specific language, called <em>Skitter</em>. Skitter enables developers to write <em>reactive components</em> and compose these into reactive workflows, which can be distributed over a cluster by Skitter&#8217;s runtime system.</p></div> </div>
<h2>SESSION: Visualization, Debugging, and Programming Techniques</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N661824" title="Get the Full Text from the ACM Digital Library">Composable higher-order reactors as the basis for a live reactive programming environment</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Bjarno Oeyen</li>
<li class="nameList">Humberto Rodriguez Avila</li>
<li class="nameList">Sam Van den Vonder</li>
<li class="nameList Last">Wolfgang De Meuter</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>A live programming environment allows programmers to edit programs while they are running. This means that successive "edit steps" must not allow a programmer to bring the program in a form that does not make any sense to the underlying language processor (i.e., parser, compiler,...). Many live programming environments therefore rely on disciplined edit steps that are based on language elements such as objects, classes, and methods. Textual modifications to these elements are not seen as edit steps until some "accept" button is hit. Unfortunately, no such elements exist in current reactive languages. We present a new reactive language, called Haai, that is based on first-class higher-order reactors. Linguistically, Haai programs correspond to reactors or compositions of reactors. At run-time, reactors produce an infinite stream of values just like signals and behaviours in existing languages. Haai&#39;s live programming environment relies on textual modifications of entire reactors as its basic edit steps. Changing a reactor automatically updates all occurrences of that reactor in the reactive program, while it is running.</p></div> </div>
<h3>
 <a class="DLtitleLink" href="https://dl.acm.org/authorize?N661835" title="Get the Full Text from the ACM Digital Library">A reactive language for analyzing cloud logs</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Guillaume Baudart</li>
<li class="nameList">Louis Mandel</li>
<li class="nameList">Olivier Tardieu</li>
<li class="nameList Last">Mandana Vaziri</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Log analysis is required in many domains, and especially in the emerging field of cloud computing. Cloud applications are often built by composing diverse services. When something goes wrong, finding the root cause of the problem can be difficult. Many services are only reachable through their Application Programming Interfaces (APIs) with no possibility for live introspection. In this context, logs become an essential tool for monitoring and debugging. Cloud services typically generate very large quantities of log messages, with formats that may not be well specified and may vary over time. In this paper, we present CloudLens, a language for the analysis of semi-structured textual data as found in logs, and specify its formal semantics. CloudLens is a reactive language and views logs as streams of objects. Our objective is to facilitate exploring the contents of logs interactively and to write reusable analyses succinctly, using familiar constructs. We implemented an interpreter for the Apache Zeppelin notebook to provide an interactive IDE. Our prototype implementation is open source and we report on a detailed case study using logs from the Apache OpenWhisk project.</p></div> </div>
</div>
</div>
</body>
</html>

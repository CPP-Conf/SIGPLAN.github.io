<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>SPLASH-E '24: Proceedings of the 2024 ACM SIGPLAN International Symposium on SPLASH-E</title></head><body><div id="DLtoc"><div id="DLheader"><h1>SPLASH-E '24: Proceedings of the 2024 ACM SIGPLAN International Symposium on SPLASH-E</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3689493"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689983">Gender Differences in Story, Game and Visual Adventures in Hedy</a></h3><ul class="DLauthors"><li class="nameList">Shirley de Wit</li><li class="nameList">Felienne Hermans</li><li class="nameList">Marcus Specht</li><li class="nameList Last">Efthimia Aivaloglou</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Even though the field of Computer Science (CS) affects different aspects of society, several groups of society are under-represented, including women and nonbinary people. Children might have different learning opportunities in CS due to their project preferences. Girls are likelier to work on stories and simple programs in Scratch, whereas boys tend to create games and more complex programs. We explore whether preferences and program implementation differ between genders within a story, game and visual adventure in Hedy, a gradual textual programming language. We analysed 14,233 programs within five Hedy levels created by 2,819 users who turned 10 to 14 in 2023. We found that boys, girls and nonbinary children worked most on the game adventure. Within the individual adventures, gender differences occur in all three adventures in the most elaborate Hedy level analysed. However, for some levels, no gender differences were found. Thus, programming assignments can be created in which children of different genders work on similar programs in terms of size and number of (unique) commands used.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689984">Roles of Variables in the Hedy Programming Language</a></h3><ul class="DLauthors"><li class="nameList">Julia Vanwijnsberghe-Bolt</li><li class="nameList Last">Felienne Hermans</li></ul><div class="DLabstract"><div style="display:inline">
				<p>The concept of variables can be hard to grasp for novices. The Roles of Variables framework has been found to enhance learning elementary programming. The 11 roles can describe all variables in novice programs in 99% of the cases. Prior work has shown that the roles give novices better program comprehension capabilities and better programming skills. In this paper we apply the Roles of Variables to Hedy. Hedy is a gradual and multilingual programming language for education. It consists of 18 levels, each supporting new concepts or requiring code that satisfies new syntax rules, to gradually learn programming in Python, and it is available in 50 different (natural) languages. In this paper we explore how to integrate the roles into Hedy. We reflect on the roles by applying them in a new setting and it could later on become useful for the users of Hedy.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689978">Using Computation Graphs to Explain Nondeterminism to Students</a></h3><ul class="DLauthors"><li class="nameList">Marco T. Morazán</li><li class="nameList Last">Oliwia Kempinski</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Students find their first course in Formal Languages and Automata Theory challenging. Most students struggle to understand nondeterministic computation models like nondeterministic finite-state machines, pushdown automata, and Turing machines. Often, students find it difficult to understand why a nondeterministic machine accepts or rejects a word. Furthermore, they may feel uncomfortable with there being multiple computations on the same input and with a computation not consuming all of its input. This article presents a visualization tool developed to help students understand nondeterministic behavior. The tool is integrated into FSM--a domain-specific language for the Automata Theory classroom. The strategy is based on the automatic generation of computation graphs. Unlike previous visualization tools, the computation graphs generated reflect the structure of the given machine's transition diagram and not the structure of the computation tree. Empirical data collected from students at two universities suggests that the visualizations are well-received and useful.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689979">Visualizing Composed Turing Machines</a></h3><ul class="DLauthors"><li class="nameList">Marco T. Morazán</li><li class="nameList">Tijana Minić</li><li class="nameList Last">Oliwia Kempinski</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In their first Formal Languages and Automata Theory course students find Turing machine composition challenging. In addition to the development of formal arguments, most students struggle with the idea that a Turing machine may use auxiliary Turing machines to solve a problem. This struggle is significant despite understanding that the use of auxiliary Turing machines is tantamount to using auxiliary functions in a program. This article presents two visualization tools developed to help students understand Turing machine composition. These tools are integrated into FSM--a domain-specific functional language for the Automata Theory classroom. The first is a static visualization tool that generates the transition diagram of a given composed Turing machine. The second is an interactive tool that simulates the execution of a given composed Turing machine. Empirical data collected from students is presented that suggests that the tools are well-received, easy to use, and useful.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689982">Programming Smart Objects: How Young Learners’ Programming Skills, Attitudes, and Perception Are Influenced</a></h3><ul class="DLauthors"><li class="nameList">Mazyar Seraj</li><li class="nameList">Mauricio Verano Merino</li><li class="nameList">Ebrahim Rahimi</li><li class="nameList Last">Lina Ochoa Venegas</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Programming literacy is crucial for current and future generations of young learners, irrespective of their career paths. Programming education is thus essential, making teaching methods and tools to be tailored to the target audience. In this context, contemporary visual programming environments, particularly block-based programming, have become instrumental in introducing programming concepts to young learners. Educational theories such as Constructionism advocate an approach centered on the learner to deepen and motivate learning. In computer science, these theories can be applied by providing hands-on experiences that connect computer science to real-life situations through the manipulation or construction of physical and tangible computational devices. This study explores the impact of creating a smart object for a smart home using block-based programming on young learners' attitudes and perceptions toward programming and their programming skills acquisition. An introductory programming workshop involved 28 8th grade students from a secondary school constructing and programming a smart-lighting object in a smart home setting. Performance, attitude, and perception trajectories were assessed through repeated questionnaires. Our results indicate that constructing and programming a real-life smart object enhances learners' confidence and programming skills. This paper contributes to programming education literature by demonstrating the potential of block-based programming, specifically in the context of state-of-the-art smart technologies, to foster programming skills and develop positive attitudes and perceptions among learners.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689985">A Word about Programming: Applying a Natural Language Vocabulary Acquisition Model to Programming Education</a></h3><ul class="DLauthors"><li class="nameList">Marcella Veldthuis</li><li class="nameList Last">Felienne Hermans</li></ul><div class="DLabstract"><div style="display:inline">
				<p>A programming language is a textual language with syntax and semantics, and so is a natural language. Because of these similar characteristics, it is proposed that learning to program is similar to learning a new natural language. The goal of this paper is to evaluate the effectiveness when a natural language vocabulary acquisition model is used in programming education for beginners. This study involves a class of 26 students enrolled in lower secondary education. We apply a model for learning vocabulary to programming concepts. We redesign three lessons of an introductory programming course and replace them with lessons in which natural language strategies are used. Based on lesson observations, written and verbal student feedback, and an analysis of the students' work, we aim to understand the effects of this intervention on both student performance and motivation. Our findings show that the students have effectively learned and practiced programming concepts. They also show high levels of motivation, by expressing enthusiasm and dedication towards their learning process. When asked for feedback students state how they thought the learning process is fun. They appreciate the lesson structure and set-up, the themes, the way they receive instruction, and that they are allowed to collaborate with other students. Challenges of our approach are that our lessons made use of paper handouts, and although students did quite well when working on the programming assignments, they showed a great dislike for working on paper that negatively affected their motivation. Also, transitioning to a different kind of lessons takes time and effort, and we need to make sure to create a safe classroom environment in which students feel free to get creative, brainstorm and associate.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689981">ASSIST: Automated Feedback Generation for Syntax and Logical Errors in Programming Exercises</a></h3><ul class="DLauthors"><li class="nameList">Lucas Van Praet</li><li class="nameList">Jesse Hoobergs</li><li class="nameList Last">Tom Schrijvers</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Introductory programming courses often rely on numerous exercises to help students practice and reinforce their skills. Commonly used automated tests fall short by merely identifying the issues without offering guidance on how to resolve them and manual reviews are too resource-intensive to use in large classes. To address these challenges, we present ASSIST—a tool designed to provide automated, detailed feedback on how to resolve issues in programming exercise submissions with both syntactic and logical errors. ASSIST combines fault-tolerant parsing with fixes based on the context of error nodes to resolve syntactic errors and give feedback. ASSIST feeds this valid program to the Sketch program synthesis tool to determine the needed changes from a set of potential changes induced by rewrite rules, and generates feedback on logic errors based on the needed changes. This dual approach allows ASSIST to offer actionable feedback on both syntax and logic issues in student submissions. We evaluated ASSIST on submissions from an online platform for secondary education. Our findings reveal that, for submissions with syntax errors, ASSIST delivers feedback on all syntax errors in 71% of cases and extends its feedback to cover logical errors in 34% of these submissions. When evaluating all incorrect submissions, ASSIST is able to give feedback on logical errors in 64% of cases. These results indicate that ASSIST can significantly enhance the feedback process in large-scale programming courses, offering a feasible and efficient alternative to current methods.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689986">An Observational Study of Undergraduate Teaching Assistants’ Use of Subgoal Learning Integrated in an Introductory Programming Course</a></h3><ul class="DLauthors"><li class="nameList">Olivier Goletti</li><li class="nameList">Kim Mens</li><li class="nameList Last">Felienne Hermans</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In this paper we study an approach to support undergraduate teaching assistants - UTAs - in their teaching with more pedagogical content knowledge. This paper builds upon prior work on the integration of explicit strategies to observe and analyse how UTAs make actual use of subgoal learning (SL) as explicit instructional strategy in their daily teaching practice. From empirical evidence, we extract instructional design advice on how to integrate different subgoal learning strategies throughout a CS1 course.
 
 
 
 
 
 
 

 
 
 
 
 
 
 
Our study 1) focuses on the effects of SL integration in UTA practice, 2) explores fidelity of their implementation of SL and 3) studies the different ways UTAs use the strategies. We use observations and surveys to analyse UTAs interventions during their lab sessions, and cross these observations results with UTAs' self-reported data through two surveys. 
 
 
 
 
 
 
 

 
 
 
 
 
 
 
Our main results are that SL integration through exercises is a major trigger of strategy use. Training and follow-up of the UTAs have impact, since UTAs feeling familiar with subgoal learning correlates positively with their successful observed use of subgoal learning. More frequent and stronger uses of the strategy were observed by UTAs self-reporting more frequent uses. And finally, UTAs express that subgoals are best suited for introducing concepts and especially the more structured ones.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689987">Judicious: API Documentation for Novices</a></h3><ul class="DLauthors"><li class="nameList">Luca Chiodini</li><li class="nameList">Simone Piatti</li><li class="nameList Last">Matthias Hauswirth</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Programmers frequently consult API documentation to learn how to use libraries,
 
 
 
both those included with a programming language and those offered by third parties.
 
 
 
Beginner programmers also have this need
 
 
 
but struggle to browse professional documentation systems,
 
 
 
which are aimed at experienced programmers.
 
 
 
Educators sometimes try to patch this problem by writing simplified, ad hoc educational documents as a surrogate for a documentation system.
 
 
 

 
 
 
This paper presents Judicious, an API documentation system explicitly designed for novice programmers.
 
 
 
It allows retrieving the documentation for one name at a time;
 
 
 
offers a clear and distinctive visual representation of functions and constants;
 
 
 
gradually presents more information such as types, optional and variable-length parameters for functions;
 
 
 
highlights functions with side effects;
 
 
 
and instantaneously generates documentation also for functions defined in student code. 
 
 
 

 
 
 
Judicious's design builds on prior research in the learning sciences and programming languages.
 
 
 
The gradual disclosing of information matches the progression of increasingly larger subsets of programming languages.
 
 
 
The diagrammatic representation,
 
 
 
the clear distinction between functions and constants,
 
 
 
and the pinpointing of side effects
 
 
 
aim to address known novice misconceptions. 
 
 
 
The system is integrated into a code editor and is publicly available as a web platform.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689493.3689980">Mocking Temporal Logic</a></h3><ul class="DLauthors"><li class="nameList Last">Colin S. Gordon</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Temporal logics cover important classes of system specifications dealing with system behavior over time. Despite the prevalence of long-running systems that accept repeated input and output, and thus the clear relevance of temporal specifications to training software engineers, temporal logics are rarely taught to undergraduates.    We motivate and describe an approach to teaching temporal specifications and temporal reasoning indirectly through teaching students about <em>mocking dependencies</em>, which is widely used in software testing of large systems (and therefore of more obvious relevance to students), less notationally intimidating to students, and still teaches similar reasoning principles. We report on 7 years of experience using this indirect approach to behavioral specifications in a software quality course.</p>
			</div></div>
							
						</div></div></body></html>
<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>PAINT '24: Proceedings of the 3rd ACM SIGPLAN International Workshop on Programming Abstractions and Interactive Notations, Tools, and Environments</title></head><body><div id="DLtoc"><div id="DLheader"><h1>PAINT '24: Proceedings of the 3rd ACM SIGPLAN International Workshop on Programming Abstractions and Interactive Notations, Tools, and Environments</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3689488"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689488.3689989">Block-Based Platform for Defining Adaptation Rules for Automotive Systems</a></h3><ul class="DLauthors"><li class="nameList">Luigi Altamirano</li><li class="nameList">Mauricio Verano Merino</li><li class="nameList Last">Ion Barosan</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Adaptive human-machine interfaces (HMIs) enhance driver safety and comfort by tailoring information presentation. While existing research identifies key adaptation parameters, their practical application remains challenging due to the complexity of rule-based decision making and the limitations of current authoring tools.
 
 
 
To address these issues, this paper introduces AHSL, a domain-specific language for efficiently specifying message adaptation logic. By unifying established adaptation parameters within a hierarchical structure, AHSL simplifies rule creation and improves readability. Usability testing demonstrates AHSL's effectiveness in supporting intuitive and efficient decision logic development.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689488.3689990">Supporting Construction of Domain-Specific Representations in Textual Source Code</a></h3><ul class="DLauthors"><li class="nameList">Tom Beckmann</li><li class="nameList">Jan Reppien</li><li class="nameList">Jens Lincke</li><li class="nameList Last">Robert Hirschfeld</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Domain-specific replacements (DSR) allow programmers to view code in a manner better suited to the domain they are working in. Creating such DSRs, however, is not trivial as it requires knowledge of programming language internals to detect relevant patterns in the source code.
 
 
 
 
 
 
 
In this paper, we propose a workflow that facilitates the matching of syntax tree structures and creation of DSRs without requiring expertise in programming language internals. In our workflow, authors express the patterns they want using syntax familiar to them when possible and receive immediate feedback and means for simple discovery for the other cases. We demonstrate the feasibility of our workflow through a prototypical implementation and evaluate it through three case studies. Through this workflow, we aim to further support authors in creating views on source code that support their work better than text.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689488.3689991">Bridging Incremental Programming and Complex Software Development Environments</a></h3><ul class="DLauthors"><li class="nameList">Max Boksem</li><li class="nameList Last">L. Thomas van Binsbergen</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In modern software development, programmers typically choose between two main types of coding environments: Incremental Programming Environments (IPEs), such as the Read-Eval-Print-Loop (REPL) interpreter IPython and the Jupyter Computational Notebook, and Integrated (text-based) Development Environments (IDEs), such as Visual Studio Code. IPEs excel in providing immediate feedback for iterative development, testing, and debugging, making them ideal for fields like data science and AI. However, their typically linear and isolated interface struggles with managing the complexity of larger software projects. Conversely, traditional IDEs support extensive project management and debugging tools suited for complex applications but lack the interactive and incremental nature of IPEs.
 

 
This paper reports on an ongoing investigation and design of a hybrid environment that combines benefits of IPEs and IDEs and the programming styles they naturally support. 
 
Central to our design is a graph structure representing code fragments as nodes and code structure as edges. By considering various types of nodes and relationships (e.g. for representing class membership, execution order, documentation, and dependencies) we can facilitate aspects of both incremental programming (in IPEs) and complexity management (in IDEs). We demonstrate our approach with a prototype, called Incremental Graph Code (IGC), by presenting its architecture and a showcase. We demonstrate IGC's functionality and discuss its potential advantages over existing environments. Key features include advanced code visualization, modular and incremental development, and complexity management. IGC aims to provide a unified, extensible, and flexible development environment that bridges the gap between different styles of programming.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689488.3689992">Advanced Game Engine Wizardry for Visual Programming Environments</a></h3><ul class="DLauthors"><li class="nameList">Elisabeth Kletsko</li><li class="nameList Last">Riemer van Rozen</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Visual programming environments empower end-users with interactive input and feedback mechanisms that support live and exploratory programming. For creating these environments, language engineers require enabling technology. Language workbenches and meta-programming languages support rapid construction of interpreter back-ends. Game engines are specifically created for rich interactive user experiences and have the potential to augment this technology even further with maintainable front-ends. However, these technologies presently live in separate technological spaces. We aim to automate the creation of visual programming environments by integrating the two. We propose Raven, a meta-framework for rapidly prototyping visual editors that exposes key 2D features of Godot in a programmable user interface. Using Raven's declarative notation, language engineers can concisely express the structure and styling of tree-based editors. We demonstrate our approach by: 1) integrating Raven into the Rascal language workbench; and 2) creating two editors for the live state machine language.</p>
			</div></div>
							
						</div></div></body></html>
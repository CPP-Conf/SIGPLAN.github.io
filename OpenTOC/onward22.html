<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>Onward! 2022: Proceedings of the 2022 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</title></head><body><div id="DLtoc"><div id="DLheader"><h1>Onward! 2022: Proceedings of the 2022 ACM SIGPLAN International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3563835"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567654">Contextualized Programming Language Documentation</a></h3><ul class="DLauthors"><li class="nameList">Hannah Potter</li><li class="nameList">Ardi Madadi</li><li class="nameList">René Just</li><li class="nameList Last">Cyrus Omar</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Learning the syntax and semantics of a new programming language is a challenge. It is common for learners to refer to language documentation many times and in many contexts as they build comfort and understanding. We review existing functional language documentation, finding that it tends to be organized according to the structure of the language. Each section interleaves narrative explanations, which introduce precise terminology that is then used consistently, with code examples. Sections often start with simpler special cases of a construct before considering it in full generality. 
</p>
<p>
To make use of language documentation, learners must step away from the code they are working with, e.g., in an exercise or tutorial, to locate and transfer knowledge from the documentation. We describe a system, ExplainThis, that automatically generates contextualized language documentation, structured based on our study of language documentation but specialized to the particular code at the cursor. This system is integrated into the structure editor of Hazel, a live functional environment. Documentation appears next to the editor and color is used as secondary notation to correlate the explanation with program terms. We also study syntactic and explanatory specificity with a formative user study. We find that participants desire documentation to be tailored to specific syntax of the code a user is working with, while allowing an adaptive level of specificity for code examples.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567655">GOAL: Supporting General and Dynamic Adaptation in Computing Systems</a></h3><ul class="DLauthors"><li class="nameList">Ahsan Pervaiz</li><li class="nameList">Yao Hsiang Yang</li><li class="nameList">Adam Duracz</li><li class="nameList">Ferenc Bartha</li><li class="nameList">Ryuichi Sai</li><li class="nameList">Connor Imes</li><li class="nameList">Robert Cartwright</li><li class="nameList">Krishna Palem</li><li class="nameList">Shan Lu</li><li class="nameList Last">Henry Hoffmann</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Adaptive computing systems automatically monitor their behavior and dynamically adjust their own configuration parameters—or knobs—to ensure that user goals are met despite unpredictable external disturbances to the system. A major limitation of prior adaptation frameworks is that their internal adaptation logic is implemented for a specific, narrow set of goals and knobs, which impedes the development of complex adaptive systems that must meet different goals using different sets of knobs for different deployments, or even change goals during one deployment. </p><p>To overcome this limitation we propose GOAL, an adaptation framework distinguished by its virtualized adaptation logic implemented independently of any specific goals or knobs. GOAL supports this logic with a programming interface allowing users to define and manipulate a wide range of goals and knobs within a running program. We demonstrate GOAL’s benefits by using it re-implement seven different adaptive systems from the literature, each of which has a different set of goals and knobs. We show GOAL’s general approach meets goals as well as prior approaches designed for specific goals and knobs. In dynamic scenarios where the goals and knobs are modified at runtime, GOAL achieves 93.7</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567656">Exploring Task Equivalence for Software Engineering Practice Adaptation and Replacement</a></h3><ul class="DLauthors"><li class="nameList Last">Diana Kirk</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Practice adaptation in the domain of software engineering (SE) is ubiquitous and well-studied. The main rationale for tailoring lies in the complexity of the environments within which SE projects are implemented. This complexity means that the practices that make up software methodologies are often not fit-for-purpose as-is and must be replaced or adapted to suit local context. However, there is a risk that a practice may be changed in an inappropriate way, with unintended side-effects. For example, altering a practice to reduce documentation may result in a failure to meet standards expectations or the expectations of downstream practices. In this paper, we describe a study that explored the notion of <em>practice equivalence</em>. Our goal was to identify aspects of a practice that are ‘similar’ and might support adaptation. We found that adapted practices must be within the same software function, perform the same action, be compatible in terms of creativity, reasoning and perspectives and have a compatible interface type. Our contributions are the consideration of an as-yet unexplored area of software process that we hope will generate discussion and future research studies and the creation of a strawman framework that will be a starting point for further exploration and evaluation.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567657">Digital Crochet: Toward a Visual Language for Pattern Description</a></h3><ul class="DLauthors"><li class="nameList">Klara Seitz</li><li class="nameList">Patrick Rein</li><li class="nameList">Jens Lincke</li><li class="nameList Last">Robert Hirschfeld</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Crochet is still purely manual. While other crafts such as knitting or weaving have received technical support, the process of creating instructions for new crochet patterns is barely supported by domain-specific, digital tools. Those tools are constrained by their underlying crochet pattern languages that are either ambiguous or limited in their expressiveness. As a result, creating crochet instructions requires substantial manual effort and can result in incomplete or ambiguous instructions after all.  
</p>
<p>
We propose a first visual, domain-specific, graph-based language for crochet pattern representation. We show how this language can be leveraged to provide domain-specific tool support by a prototypical implementation of an editor for creating patterns in 2D and viewing them in 3D. In a user study, we demonstrate that the proposed language allows pattern designers to express both 2D and 3D patterns and removes ambiguities observed in current standard notations.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567658">Derivations with Holes for Concept-Based Program Synthesis</a></h3><ul class="DLauthors"><li class="nameList">João Costa Seco</li><li class="nameList">Jonathan Aldrich</li><li class="nameList">Luís Carvalho</li><li class="nameList">Bernardo Toninho</li><li class="nameList Last">Carla Ferreira</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Program synthesis has the potential to democratize programming by enabling non-programmers to write software. But conventional approaches to synthesis may fail if given insufficient information - a common occurrence when asking non-experts to describe the application they want to write. This paper introduces a new concept-based program synthesis mechanism that can cope with incomplete knowledge, targeting low-code model-driven languages. Concepts are modelled in an ontology that represents user intent including basic actions (e.g. show, filter, and create) along with their associated data as well as basic user interface structures like screens or pages. Our synthesis framework consists of a system of derivation rules that supports deferred premises, which need not be immediately satisfied during synthesis. A derivation in which some deferred premises are missing will thus contain holes; semantically, it represents a proof that is conditional on the developer filling the holes with additional facts from the ontology. We translate derivations with holes to standard first-order logic derivations, where the holes are transformed into assumptions. We illustrate the feasibility and effectiveness of our framework with a proof-of-concept implementation and a set of illustrative examples.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567668">Bridging the Syntax-Semantics Gap of Programming</a></h3><ul class="DLauthors"><li class="nameList">Theo B. Weidmann</li><li class="nameList">Sverrir Thorgeirsson</li><li class="nameList Last">Zhendong Su</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Computer programming typically requires people to describe operations in a formally specified textual language. Unfortunately, working with syntax is a significant cognitive load, making programming difficult for beginners and time-consuming for professional developers. In response to this, contemporary research often focuses on abstracting or improving the process of composing code. We believe, however, that one fundamental reason why programming is difficult is the disconnect between the symbols and metaphors used in code and the mechanics they represent. Programming languages use abstractions whose superficial similarities to natural language neither effectively help users understand programs nor enable them to work creatively. To tackle this fundamental limitation, this paper introduces a new language based on a novel programming-by-demonstration paradigm that (i) enables users to experiment and test their programs, (ii) allows describing complex operations without the need to learn any syntax, and (iii) always displays an approximation of the program state while programming a new operation. We explain the rationales behind our new approach and present our design and implementation using illustrative examples and a supplemental video recording.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567660">A Language Based on Two Relations between Symbols</a></h3><ul class="DLauthors"><li class="nameList Last">Agustín Rafael Martínez</li></ul><div class="DLabstract"><div style="display:inline">
				<p>We present a language with all the power of abstraction and the simplicity of two fundamental relations: substitution and categorization. With a graphic symbol representing each one of them, we created a playful visual programming environment aimed at teaching with high expressive power. This environment includes tools to inspect the program execution and a console to try visual expressions. This is achieved without resorting to text, since the symbols are user-defined drawings. To address complex problems, the language offers another set of tools to define text-based programs. Here we show a functional prototype of our rule-based, general-purpose declarative programming language.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567661">The Principles of the Flix Programming Language</a></h3><ul class="DLauthors"><li class="nameList Last">Magnus Madsen</li></ul><div class="DLabstract"><div style="display:inline">
				<p>We present the design values and design principles of the Flix programming language, a functional-first, imperative, and logic programming language. We explain how these values and principles came into being and how they have influenced the design of Flix over the last several years.  
</p>
<p>
The principles cover most facets of the Flix language and its ecosystem, including its syntax, semantics, static type and effect system, and standard library. We present each principle in detail, including its origin, rationale, and how it has shaped Flix.  
</p>
<p>
We believe that codifying a language's design values and principles can serve as a powerful medium for discussing and comparing programming language designs and we hope our presentation will inspire future language designers to document their languages' design values and principles.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567662">Intramorphic Testing: A New Approach to the Test Oracle Problem</a></h3><ul class="DLauthors"><li class="nameList">Manuel Rigger</li><li class="nameList Last">Zhendong Su</li></ul><div class="DLabstract"><div style="display:inline">
				<p>A test oracle determines whether a system behaves correctly for a given input. Automatic testing techniques rely on an automated test oracle to test the system without user interaction. Important families of automated test oracles include Differential Testing and Metamorphic Testing, which are both black-box approaches; that is, they provide a test oracle that is oblivious to the system’s internals. In this work, we propose Intramorphic Testing as a white-box methodology to tackle the test oracle problem. To realize an Intramorphic Testing approach, a modified version of the system is created, for which, given a single input, a test oracle can be provided that relates the output of the original and modified systems. As a concrete example, by replacing a greater-equals operator in the implementation of a sorting algorithm with smaller-equals, it would be expected that the output of the modified implementation is the reverse output of the original implementation. In this paper, we introduce the methodology and illustrate it via a set of use cases.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567663">Forest: Structural Code Editing with Multiple Cursors</a></h3><ul class="DLauthors"><li class="nameList">Philippe Voinov</li><li class="nameList">Manuel Rigger</li><li class="nameList Last">Zhendong Su</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Software developers frequently refactor code.  
Often, a single logical refactoring change involves changing multiple related components in a source base such as renaming each occurrence of a variable or function.  
While many code editors can perform such common and generic refactorings, they do not support more complex refactorings or those that are specific to a given code base.  
For those, as a flexible---albeit less interactive---alternative, developers can write refactoring scripts that can implement arbitrarily complex logic by manipulating the program's tree representation.  
In this work, we present Forest, a structural code editor that aims to bridge the gap between the interactiveness of code editors and the expressiveness of refactoring scripts.  
While structural editors have occupied a niche as general code editors, the key insight of this work is that they enable a novel structural multi-cursor design that allows Forest to reach a similar expressiveness as refactoring scripts; Forest allows to perform a single action simultaneously in multiple program locations and thus support complex refactorings.  
To support interactivity, Forest provides features typical for text code editors such as writing and displaying the program through its textual representation.  
Our evaluation demonstrates that Forest allows performing edits similar to those from refactoring scripts, while still being interactive.  
We attempted to perform edits from 48 real-world refactoring scripts using Forest and found that 11 were possible, while another 17 would be possible with added features.  
We believe that a multi-cursor setting plays to the strengths of structural editing, since it benefits from reliable and expressive commands. Our results suggest that multi-cursor structural editors could be practical for performing small-scale specialized refactorings.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567664">Portals: An Extension of Dataflow Streaming for Stateful Serverless</a></h3><ul class="DLauthors"><li class="nameList">Jonas Spenger</li><li class="nameList">Paris Carbone</li><li class="nameList Last">Philipp Haller</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Portals is a serverless, distributed programming model that blends the exactly-once processing guarantees of stateful dataflow streaming frameworks with the message-driven compositionality of actor frameworks. Decentralized applications in Portals can be built dynamically, scale on demand, and always satisfy strict atomic processing guarantees that are natively embedded in the framework's principal elements of computation, known as atomic streams. In this paper, we describe the capabilities of Portals and demonstrate its use in supporting several popular existing distributed programming paradigms and use-cases. We further introduce all programming model invariants and the corresponding system methods used to satisfy them.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3567665">Competitive Debugging: Toward Contests Promoting Debugging as a Skill</a></h3><ul class="DLauthors"><li class="nameList">Patrick Rein</li><li class="nameList">Tom Beckmann</li><li class="nameList">Leonard Geier</li><li class="nameList">Toni Mattis</li><li class="nameList Last">Robert Hirschfeld</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Debugging is an essential part of software development. Numerous tools and techniques to improve debugging have been proposed in research or developed in the industry. However, only a few of those see widespread use, and debugging only rarely is a primary teaching subject. </p><p>To promote debugging as a distinct skill, we propose <em>Competitive Debugging</em>, where participants compete on who can repair a failure the fastest or the most comprehensively. We further propose a format for debugging contests aimed at attracting and engaging participants to motivate them to improve their debugging skills. In our proposed format participants simultaneously work on the same failure or observe fellow participants during their debugging activity. To evaluate the format, we ran two pilots and one main event. We found that the format prompted participants to reflect on their debugging process, that the format allowed them to compare their debugging approaches to others through post-round discussions on their various approaches, and that the format was enjoyable and engaging for all participants. We present our format of a debugging contest, an evaluation of the trial runs we performed, and give guidance for other people who consider hosting a Competitive Debugging event. </p><p>Ultimately, we aim to provide developers with opportunities to improve their debugging skills. Our observations indicate that Competitive Debugging can provide such opportunities to train debugging techniques and learn new tools.</p>
			</div></div>
							
						<h2>SESSION: Essays</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3568733">Relentless Repairability or Reckless Reuse: Whether or Not to Rebuild a Concern with Your Familiar Tools and Materials</a></h3><ul class="DLauthors"><li class="nameList">Marcel Taeumel</li><li class="nameList Last">Robert Hirschfeld</li></ul><div class="DLabstract"><div style="display:inline">
				<p>We must retain liveness and exploratory practices within the programming systems that make us feel most productive. However, the temptation to just reuse <em>black boxes</em> through limited interfaces is pervasive. We <em>expect</em> time savings and better performance at the cost of <em>poor repairability</em>. Fortunately, we also know about the benefits of having an open implementation constructed from familiar materials, integrated with familiar tools. Consequently, it is primarily a matter of “just building it” ... again? Piece of cake. What could possibly go wrong?</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3568734">Conferences &amp; Остраннeние: Shortchanging Topos and Ourselves</a></h3><ul class="DLauthors"><li class="nameList">Richard P. Gabriel</li><li class="nameList Last">Jenny Quillien</li></ul><div class="DLabstract"><div style="display:inline">
				<p>What is a conference for? What are its design considerations? What are the trade-offs between virtual and <em>terrestrial</em> meetings? Within these larger frame questions, this essay looks <em>only</em> at the following argument: </p><p>The first critical step in research is the hypothesis—the novel idea to be explored. This step typically requires the mysterious phenomena of an intuitive leap of mind. Fertile soil for that leap is one of the most valuable affordances a conference can provide. Potential generative power lies within <em>topos</em> (place) and остраннeние (estrangement). They have been overlooked in discussions about conference design of all types. Cutting access to these deeper physical and intellectual roots reduces our ability to think new thoughts. </p><p>Put them back in.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3568735">What Object-Oriented Programming Was Supposed to Be: Two Grumpy Old Guys’ Take on Object-Oriented Programming</a></h3><ul class="DLauthors"><li class="nameList">Ole Lehrmann Madsen</li><li class="nameList Last">Birger Møller-Pedersen</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Object-oriented programming has been around for more than 50 years and is now the most dominant style of programming. In recent years there has been an increasing criticism of object-oriented programming. Some people argue that the mainstream object-oriented languages do not capture the intentions of object-orientation as intended by its founding fathers. There are indeed issues with object-orientation as practiced by mainstream. In this essay, we identify a number of issues that we think are problematic. We argue that the primary reason for these issues is that reuse is considered the main advantage of object-orientation at the expense of modeling. We argue that modeling should be the main focus, that programming is modeling, and we describe a number of principles to follow when practicing object-oriented modeling.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3568736">Ascending the Ladder to Self-Sustainability: Achieving Open Evolution in an Interactive Graphical System</a></h3><ul class="DLauthors"><li class="nameList">Joel Jakubovic</li><li class="nameList Last">Tomas Petricek</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Programming is usually based on an inconvenient separation between an <em>implementation</em> level and a <em>user</em> level. <em>Self-sustaining</em> systems expose their implementation at their user level so that they can be modified and improved from within. However, the few examples that exist are tightly linked to textual language-based accounts of compiler bootstrapping. If we want systems to be truly open for modification, we need to step beyond programming <em>languages</em> and support more structured, visual ways of programming as well. How the bootstrapping process can work in such an interactive context is important yet unexplored territory. </p><p>This essay is a critical report on our first-hand experience of building one such system named <em>BootstrapLab</em>. We trace and reconstruct the steps for achieving self-sustainability in an interactive, structured, graphical context: choose the platform; design the substrate; implement temporary infrastructure; implement a high-level language; pay off outstanding substrate debt; provide for domain-specific notations. </p><p>Throughout, we discuss the challenges involved, identifying design <em>forces</em> that shaped the decisions and capturing <em>heuristics</em> that resolved these forces in our case. Both positive and negative results are featured, including the efficacy of the heuristics. We close by suggesting how to generalise what worked in our particular case to alternative paths and starting points. The enterprise as a whole takes us a further step towards achieving open and malleable programming systems for everyone.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3563835.3568737">Bringing Together Configuration Research: Towards a Common Ground</a></h3><ul class="DLauthors"><li class="nameList">Paul Gazzillo</li><li class="nameList Last">Myra B. Cohen</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Configurable software makes up most of the software in use today. Configurability, i.e., the ability of software to be customized without additional programming, is pervasive, and due to the criticality of problems caused by misconfiguration, it has been an active topic researched by investigators in multiple, diverse areas. This broad reach of configurability means that much of the literature and latest results are dispersed, and researchers may not be collaborating or be aware of similar problems and solutions in other domains. We argue that this lack of a common ground leads to a missed opportunity for synergy between research domains and the synthesis of efforts to tackle configurability problems. In short, configurability cuts across software as a whole and needs to be treated as a first class programming element. To provide a foundation for addressing these concerns we make suggestions on how to bring the communities together and propose a common model of configurability and a platform, ACCORD, to facilitate collaboration among researchers and practitioners.</p>
			</div></div>
							
						</div></div></body></html>
<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>FUNARCH 2023: Proceedings of the 1st ACM SIGPLAN International Workshop on Functional Software Architecture</title></head><body><div id="DLtoc"><div id="DLheader"><h1>FUNARCH 2023: Proceedings of the 1st ACM SIGPLAN International Workshop on Functional Software Architecture</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3609025"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609481">A Software Architecture Based on Coarse-Grained Self-Adjusting Computations</a></h3><ul class="DLauthors"><li class="nameList Last">Stefan Wehr</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Ensuring that software applications  
present their users the most recent version of data is not trivial.  
Self-adjusting computations are a technique for automatically and efficiently recomputing  
output data whenever some input changes.  
</p>
<p>
This article describes the software architecture of a large, commercial  
software system built around a framework for coarse-grained self-adjusting  
computations in Haskell. It discusses advantages and disadvantages  
based on longtime experience.  
The article also presents a demo of the system  
and explains the API of the framework.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609480">Crème de la Crem: Composable Representable Executable Machines</a></h3><ul class="DLauthors"><li class="nameList">Marco Perone</li><li class="nameList Last">Georgios Karachalias</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In this paper we describe how to build software architectures as a composition of state machines, using ideas and principles from the field of Domain-Driven Design. By definition, our approach is modular, allowing one to compose independent subcomponents to create bigger systems, and representable, allowing the implementation of a system to be kept in sync with its graphical representation.  
</p>
<p>
In addition to the design itself we introduce the Crem library, which provides a concrete state machine implementation that is both compositional and representable. Crem uses Haskell's advanced type-level features to allow users to specify allowed and forbidden state transitions, and to encode complex state machine---and therefore domain-specific---properties. Moreover, since Crem's state machines are representable, Crem can automatically generate graphical representations of systems from their domain implementations.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609478">Functional Shell and Reusable Components for Easy GUIs</a></h3><ul class="DLauthors"><li class="nameList">D. Ben Knoble</li><li class="nameList Last">Bogdan Popa</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Some object-oriented GUI toolkits tangle state management with rendering. Functional shells and observable toolkits like GUI Easy simplify and promote the creation of reusable views by analogy to functional programming. We have successfully used GUI Easy on small and large GUI projects. We report on our experience constructing and using GUI Easy and derive from that experience several architectural patterns and principles for building functional programs out of imperative systems.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609479">Phases in Software Architecture</a></h3><ul class="DLauthors"><li class="nameList">Jeremy Gibbons</li><li class="nameList">Donnacha Oisín Kidney</li><li class="nameList">Tom Schrijvers</li><li class="nameList Last">Nicolas Wu</li></ul><div class="DLabstract"><div style="display:inline">
				<p>The large-scale structure of executing a computation can often be thought of as being separated into distinct <em>phases</em>. But the most natural form in which to <em>specify</em> that computation may well have a different and conflicting structure. For example, the computation might consist of gathering data from some locations, processing it, then distributing the results back to the same locations; it may be executed in three phases—gather, process, distribute—but mostly conveniently specified orthogonally—by location. We have recently shown that this multi-phase structure can be expressed as a novel <em>applicative functor</em> (also known as an <em>idiom</em>, or <em>lax monoidal</em> functor). Here we summarize the idea from the perspective of software architecture. At the end, we speculate about applications to choreography and multi-tier architecture.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609476">Stretching the Glasgow Haskell Compiler: Nourishing GHC with Domain-Driven Design</a></h3><ul class="DLauthors"><li class="nameList">Jeffrey M. Young</li><li class="nameList">Sylvain Henry</li><li class="nameList Last">John Ericson</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Over the last decade Haskell has been productized; transitioning from a  
 research language to an industrial strength language ready for large-scale  
 systems. However, the literature on architecting such systems with a pure  
 functional language is scarce. In this paper we contribute to that discourse,  
 by using a large-scale system: the Glasgow Haskell Compiler (GHC), as a guide  
 to more maintainable, flexible and effective, pure functional architectures.  
 We describe, from experience, how GHC as a system, violates the desirable  
 properties that make pure functional programming attractive: immutability,  
 modularity, and composability. With these violations identified, we provide  
 guidance for other functional system architectures; drawing heavily on  
 Domain-Driven Design. We write from an engineering perspective, with the hope  
 that our experience may provide insight into best practices for other pure  
 functional software architects.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609477">Typed Design Patterns for the Functional Era</a></h3><ul class="DLauthors"><li class="nameList Last">Will Crichton</li></ul><div class="DLabstract"><div style="display:inline">
				<p>This paper explores how design patterns could be revisited in the era of mainstream functional programming languages. I discuss the kinds of knowledge that ought to be represented as functional design patterns: architectural concepts that are relatively self-contained, but whose entirety cannot be represented as a language-level abstraction. I present four concrete examples embodying this idea: the Witness, the State Machine, the Parallel Lists, and the Registry. Each pattern is implemented in Rust to demonstrate how careful use of a sophisticated type system can better model each domain construct and thereby catch user mistakes at compile-time.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3609025.3609475">Types that Change: The Extensible Type Design Pattern</a></h3><ul class="DLauthors"><li class="nameList Last">Ivan Perez</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Compilers are often structured as chains of transformations, from source code to object code, through multiple intermediate representations. The existence of different representations of the same program presents challenges both for code maintenance and in terms of architecture. The types used to capture programs at multiple stages may be similar but not interchangeable, leading to code duplication. Methods to alleviate such duplication often lead to violations of software engineering principles of abstraction and encapsulation. This pearl discusses a design pattern where an algebraic data type (ADT) is extended with an argument type function that is applied to every component of the ADT. The resulting parametric type can be instantiated with multiple type functions, each providing a different feature. We demonstrate the versatility of this pattern by capturing notions of traceability and error recovery, and demonstrate that it can also be used to selectively modify existing types, as well as to extend them. Our proposal has been validated by applying it to a real-world use case with very good results.</p>
			</div></div>
							
						</div></div></body></html>
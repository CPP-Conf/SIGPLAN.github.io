<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>SPLASH-E 2023: Proceedings of the 2023 ACM SIGPLAN International Symposium on SPLASH-E</title></head><body><div id="DLtoc"><div id="DLheader"><h1>SPLASH-E 2023: Proceedings of the 2023 ACM SIGPLAN International Symposium on SPLASH-E</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3622780"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623644">Teaching Programming with Graphics: Pitfalls and a Solution</a></h3><ul class="DLauthors"><li class="nameList">Luca Chiodini</li><li class="nameList">Juha Sorva</li><li class="nameList Last">Matthias Hauswirth</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Many introductory programming courses employ graphics  
libraries that promote engagement and enable fun visuals.  
However, student excitement over graphical outputs is not a  
guarantee of conceptual understanding of programming, and  
graphics may even distract from intended learning outcomes.  
Our contribution is twofold. First, we analyze a selection of  
existing graphics libraries designed for novice programmers.  
We consider how these libraries foster clean decomposition,  
direct students’ attention to key content, and manage complexity; we find shortcomings in these respects. These shortcomings involve the libraries’ support for global coordinates  
and external graphics, as well as their rich APIs; we argue  
that these features, although powerful, are also potential  
pitfalls in student learning. Second, we present the design of  
a new graphics library, PyTamaro, which avoids the pitfalls  
with a minimalist design that eschews coordinates; we also  
outline a pedagogical approach that builds on PyTamaro’s  
strengths and deliberate limitations. We briefly discuss PyTamaro’s trade-offs in comparison to coordinate-based libraries.  
The work reported here paves the way for future empirical  
evaluations of PyTamaro and associated teaching practices.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623645">A Framework for the Localization of Programming Languages</a></h3><ul class="DLauthors"><li class="nameList">Alaaeddin Swidan</li><li class="nameList Last">Felienne Hermans</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Most programming languages are only available in English, which means that speakers of other languages need to learn at least some English before they can learn to program. This creates well-documented barriers to entry into programming. While many educational programming languages are localized in some way (e.g. keywords), they often miss important other aspects (e.g. numerals or word order). This paper describes a framework of 12 aspects of programming languages that can be localized, helping tool designers localize their languages better and educators to make more informed decisions about introductory languages in non-English contexts.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623646">Centering Humans in the Programming Languages Classroom: Building a Text for the Next Generation</a></h3><ul class="DLauthors"><li class="nameList Last">Rose Bohrer</li></ul><div class="DLabstract"><div style="display:inline">
				<p>This paper is a companion to the author's open-access textbook, "Human-Centered Programming Languages." Beyond the contributions of the textbook itself, this paper contributes a set of textbook design principles for overcoming those limitations and an analysis of students' stated needs and preferences drawn from anonymous course report data for three courses, the last of which was based on notes that became the basis of the textbook. The textbook is intended to be multi-purpose, with its primary audiences being undergraduate and master's-level elective courses on programming languages within computer science, but significant opportunity for cross-use in disciplines ranging from human-computer interaction and software engineering to gender studies and disability studies. The book is intended to be language-agnostic, but the course in which it will be used first is Rust-based.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623647">Composing Turing Machines in FSM</a></h3><ul class="DLauthors"><li class="nameList Last">Marco Morazán</li></ul><div class="DLabstract"><div style="display:inline">
				<p>For Computer Science students, designing Turing machines is a Herculean task. Formal Languages and Automata Theory textbooks aid students by introducing a graphical notation for Turing machine composition. The difficulty of the task remains unchanged, because design principles are not emphasized and students rarely have the opportunity to program their designs in a textual programming language which allows them to write unit tests. To aid students that are trained as programmers, FSM--a domain-specific language for the Automata Theory classroom--has been developed. Using FSM, students design, program, validate, and establish the correctness of their Turing machines. Once they are familiar with Turing machines, students are introduced to Turing machine composition much like they are introduced to function composition when they learn to design programs. To compose Turing machines in FSM, there is an embedded domain-specific language that students may use. In this manner, students' training in programming is made relevant in the course. This article discusses how students are taught to design, program, validate, and establish the correctness of composed Turing machines.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623648">KOGI: A Seamless Integration of ChatGPT into Jupyter Environments for Programming Education</a></h3><ul class="DLauthors"><li class="nameList">Kimio Kuramitsu</li><li class="nameList">Yui Obara</li><li class="nameList">Miyu Sato</li><li class="nameList Last">Momoka Obara</li></ul><div class="DLabstract"><div style="display:inline">
				<p>The impact of ChatGPT has brought both anxiety and anticipation to schools and universities. Exploring a positive method to improve programming skills with ChatGPT is a new and pressing challenge.  
In pursuit of this goal, we have developed KOGI, a learning support system that integrates ChatGPT into the Jupyter environment. This paper demonstrates how KOGI enables students to receive timely advice from ChatGPT in response to errors and other questions they encounter.  
</p>
<p>
We immediately introduced KOGI in our two introductory courses: Algorithms and Data Science. The introduction of KOGI resulted in a significant decrease in the number of unresolved student errors. In addition, we report on student trends observed in the classroom regarding the type and frequency of help requested. Although our findings are preliminary, they are informative for programming instructors interested in using ChatGPT.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623649">Exploring Engagement and Self-Efficacy in an Introductory Computer Science Course</a></h3><ul class="DLauthors"><li class="nameList">Rory Kelly</li><li class="nameList Last">Meghan Allen</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Introductory computer science courses often pose unique challenges for non-computer science majoring students, and understanding the factors that contribute to these struggles is crucial for enhancing students' learning experiences. This research delves into the engagement and self-efficacy of 14 international undergraduate students enrolled in an introductory computer science course tailored for non-CS majors. We use a combination of an initial online survey and the Experience Sampling Method (ESM) to gather data on students' experiences and perceptions throughout the course. The ESM interviews conducted during students' tutorials offer real-time insight into the fluctuations of their engagement and self-efficacy. Findings reveal a positive correlation between aspects of engagement and self-efficacy, indicating that students' higher levels of engagement coincide with stronger beliefs in their capabilities to succeed in the course. Moreover, we identified course topics with which students were disengaged and that corresponded to lower self-efficacy. By recognizing the challenges faced by non-CS majoring students and the impact of specific course topics and teaching styles on their engagement and self-efficacy, we provide advice for designing tailored interventions and instructional strategies.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3622780.3623650">Witter: A Library for White-Box Testing of Introductory Programming Algorithms</a></h3><ul class="DLauthors"><li class="nameList">Afonso Caniço</li><li class="nameList Last">André Santos</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Software testing is mostly performed in a black-box manner, that is, without incorporating any knowledge of the internal workings of programs into the tests. This practice usually suffices for enterprises and general practitioners, where the focus lies on producing reliable results while most algorithmic tasks are provided by third-party libraries. However, for computer science students and the like, it might not be straightforward to discern the underlying causes of an incorrect test result or to understand why certain algorithmic goals are not met. We present Witter, a software testing library that allows programming educators to define white-box tests for Java source code. Our tests analyze the execution of a method against a reference solution, to verify that the code not only produces correct results but is also in accordance with a desired algorithm behavior.</p>
			</div></div>
							
						</div></div></body></html>

<!doctype html>
<head>
<META http-equiv="Content-Style-Type" content="text/css">
<title>SPLASH Companion 2019- Proceedings Companion of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity</title>
<STYLE type="text/css">
#DLtoc {
	font: normal 12px/1.5em Arial, Helvetica, sans-serif;
	}

#DLheader {
	}
#DLheader h1 {
	font-size:16px;	
}
	
#DLcontent {
	 font-size:12px;
	}
#DLcontent h2 {
	 font-size:14px;
	 margin-bottom:5px;
	}
#DLcontent h3 {
	 font-size:12px;
	 padding-left:20px;
	 margin-bottom:0px;
	}

#DLcontent ul{
	margin-top:0px;
	margin-bottom:0px;
	}
		
.DLauthors li{
	display: inline;
	list-style-type: none;
	padding-right: 5px;
	}
	
.DLauthors li:after{
	content:",";
	}
.DLauthors li.nameList.Last:after{
	content:"";
	}		

.DLabstract {
	 padding-left:40px;
	 padding-right:20px;
	 display:block;
	}

.DLformats li{
	display: inline;
	list-style-type: none;
	padding-right: 5px;
	}
	
.DLformats li:after{
	content:",";
	}
.DLformats li.formatList.Last:after{
	content:"";
	}		

.DLlogo {
	vertical-align:middle; 
	padding-right:5px;
	border:none;
	}
	
.DLcitLink {
	margin-left:20px;
	}	

.DLtitleLink {
	margin-left:20px;
	}	

.DLotherLink {
	margin-left:0px;
	}		
   
</STYLE>
</head>
<body>
<div id="DLtoc">
<div id="DLheader">
<h1>SPLASH Companion 2019- Proceedings Companion of the 2019 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity</h1>
<a class="DLcitLink" href="https://dl.acm.org/citation.cfm?id=3359061" title="Go to the ACM Digital Library for additional information about this proceeding"><img class="DLlogo" src="https://dl.acm.org/img/dllogo.png" alt="Digital Library logo" height="30" width="30">Full Citation in the ACM Digital Library</a>
</div>
<div id="DLcontent">
<h2>SESSION: Invited Talks</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684997" title="Get the Full Text from the ACM Digital Library">A graphical language for flexible inference in robotics and vision (invited talk)</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Frank Dellaert</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>In robotics and computer vision, there are many inference problems that come down to fusing the information from many different sensors, or a small number of sensors deployed over time. Dellaert will review how these and other problems can be posed in terms of factor graphs, which provide a graphical language in which to develop and collaborate on such problems. The talk will emphasize the advantages and intuition that come with these graphical languages, leading to both offline and online sensor fusion algorithms. One of Frank Dellaert&#8217;s current research directions is exploring the use of code generation to create high-performance, certifiable code to support autonomous systems in the real world.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684998" title="Get the Full Text from the ACM Digital Library">The algorithm for precision medicine (invited talk)</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Matthew Might</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Precision medicine promises to deliver ultra-personalized care by casting medicine as an optimization problem: identifying the best possible treatment with respect to all available data. A slew of recent advances in biology, starting with the ability to sequence the human genome, have caused an explosion in the amount of data one can collect on a single patient and a similar explosion in the complexity of reasoning about this data in order to solve this optimization problem. Computational support for the practicing physician is no longer an option. This talk covers precision medicine from the ground up for computer scientists &#8212; through a personal journey from programming languages research into academic medicine. It will demonstrate progress to date, including the now-routine use of relational programming in miniKanren to identify personalized treatments for patients with some of the rarest and most challenging diseases in the world.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684999" title="Get the Full Text from the ACM Digital Library">Programming support for evolving database applications (invited talk)</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Isil Dillig</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Database applications typically undergo several schema changes during their life cycle due to performance and maintainability reasons. Such changes to the database schema not only require migrating the underlying data to a new schema, but also re-implementing large chunks of the application code that query and update the database. In this talk, Dillig will describe her recent work on programming languages support for evolving database applications. Specifically, she will first describe her work on verifying equivalence between database applications that operate over different schema, such as those that arise before and after schema refactoring. Next, she will describe how to use this verification procedure to solve the corresponding synthesis problem: That is, given a database application and a new schema, how can we automatically generate an equivalent program over this new schema?</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684990" title="Get the Full Text from the ACM Digital Library">The software arts (invited talk)</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Warren Sack</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>The subject of Warren Sack&#8217;s talk will be The Software Arts, a book recently published in the MIT Press &#8220;Software Studies&#8221; series. Sack offers an alternative history of software that traces its roots to the step-by-step descriptions of how things were made in the workshops of eighteenth-century artists and artisans. He illustrates how software was born of a coupling of the liberal arts and the mechanical arts and argues that the arts are at the heart of computing. The Software Arts is an invitation to artists and humanists to see how their ideas are already at the very center of software; and an invitation to computer scientists to envision how they are artists and humanists too.</p></div> </div>
<h2>SESSION: Posters</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684991" title="Get the Full Text from the ACM Digital Library">Component-based computation-energy modeling for embedded systems</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Adam Seewald</li>
<li class="nameList">Ulrik Pagh Schultz</li>
<li class="nameList">Julius Roeder</li>
<li class="nameList">Benjamin Rouxel</li>
<li class="nameList Last">Clemens Grelck</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Computational energy-efficiency is a critical aspect of many modern embedded devices as it impacts the level of autonomy for numerous scenarios. We present a component-based energy modeling approach to abstract per-component energy in a dataflow computational network executed according to a given scheduling policy. The approach is based on a modeling tool and ultimately relies on battery state to support a wider range of energy-optimization strategies for power-critical devices.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684992" title="Get the Full Text from the ACM Digital Library">Toward a benchmark repository for software maintenance tool evaluations with humans</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Mat&#250;&#353; Sul&#237;r</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>To evaluate software maintenance techniques and tools in controlled experiments with human participants, researchers currently use projects and tasks selected on an ad-hoc basis. This can unrealistically favor their tool, and it makes the comparison of results difficult. We suggest a gradual creation of a benchmark repository with projects, tasks, and metadata relevant for human-based studies. In this paper, we discuss the requirements and challenges of such a repository, along with the steps which could lead to its construction.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684993" title="Get the Full Text from the ACM Digital Library">NAB: automated large-scale multi-language dynamic program analysis in public code repositories</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Alex Villaz&#243;n</li>
<li class="nameList">Haiyang Sun</li>
<li class="nameList">Andrea Ros&#224;</li>
<li class="nameList">Eduardo Rosales</li>
<li class="nameList">Daniele Bonetta</li>
<li class="nameList">Isabella Defilippis</li>
<li class="nameList">Sergio Oporto</li>
<li class="nameList Last">Walter Binder</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>This paper describes NAB, a novel framework to execute custom dynamic analysis on open-source software hosted in public repositories. NAB is fully-automatic, language-agnostic and scalable. We present NAB&#39;s key features and its architecture. We also discuss three large-scale case studies enabled by NAB on more than 56K Node.js, Java, and Scala projects</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684994" title="Get the Full Text from the ACM Digital Library">Renaissance: a modern benchmark suite for parallel applications on the JVM</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Aleksandar Prokopec</li>
 <li class="nameList">Andrea Ros&#224;</li>
<li class="nameList">David Leopoldseder</li>
<li class="nameList">Gilles Duboscq</li>
<li class="nameList">Petr T&#367;ma</li>
<li class="nameList">Martin Studener</li>
<li class="nameList">Lubom&#237;r Bulej</li>
<li class="nameList">Yudi Zheng</li>
<li class="nameList">Alex Villaz&#243;n</li>
<li class="nameList">Doug Simon</li>
<li class="nameList">Thomas W&#252;rthinger</li>
<li class="nameList Last">Walter Binder</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>This paper describes Renaissance, a new benchmark suite that covers modern JVM concurrency and parallelism paradigms.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684905" title="Get the Full Text from the ACM Digital Library">Distributed object-oriented programming with multiple consistency levels in ConSysT</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Nafise Eskandani</li>
<li class="nameList">Mirko K&#246;hler</li>
<li class="nameList">Alessandro Margara</li>
<li class="nameList Last">Guido Salvaneschi</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Data replication is essential in scenarios like geo-distributed datacenters and edge computing. Yet, it poses a challenge for data consistency. Developers either adopt high consistency at the detriment of performance or they embrace low consistency and face a much higher programming complexity. We argue that language abstractions should support associating the level of consistency to data types. We present ConSysT, a programming language and middleware that provides abstractions to specify consistency types, enabling mixing different consistency levels in the same application. Such mechanism is fully integrated with object-oriented programming and type system guarantees that different levels can be mixed only in a correct way.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684906" title="Get the Full Text from the ACM Digital Library">Towards a WebAssembly standalone runtime on GraalVM</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Salim S. Salim</li>
<li class="nameList">Andy Nisbet</li>
<li class="nameList Last">Mikel Luj&#225;n</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>WebAssembly is a binary format compilation target for languages such as C/C++, Rust and Go. It enables execution within Web browsers and as standalone programs. Compiled modules may interoperate with other languages such as JavaScript, and use external calls (imports) to interact with a host environment. Such interoperability dependencies influence the overall WebAssembly module performance and can limit Web/standalone execution capabilities. </p> <p> The implementation of a WebAssembly runtime, called TruffleWasm is described that provides a single environment for execution of both, standalone modules, and, interoperation with multiple GraalVM hosted languages such as JavaScript (GraalJS) via Truffle&#39;s interoperability framework. The Graal compiler is used to speculatively and aggressively apply profiling driven optimisations to perform Just-in-Time (JIT) code generation.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684907" title="Get the Full Text from the ACM Digital Library">MetaDL: declarative program analysis for the masses</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Alexandru Dura</li>
<li class="nameList Last">Hampus Balldin</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>While Datalog provides a high-level language for expressing static program analyses, it depends on external tooling to extract the input facts from the analyzed programs. To remove this dependency, we present MetaDL. The MetaDL system consists of a Datalog language extension for source-level program analysis and tools for generating the language extension from a description of the analyzed language.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684908" title="Get the Full Text from the ACM Digital Library">Towards language-parametric semantic editor services based on declarative type system specifications</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Daniel A. A. Pelsmaeker</li>
<li class="nameList">Hendrik van Antwerpen</li>
<li class="nameList Last">Eelco Visser</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>New programming languages often lack good IDE support, as developing advanced semantic editor services takes additional effort. In previous work we discussed the operational requirements of a constraint solver that leverages the declarative type system specification of a language to provide language-parametric semantic editor services. In this work we describe the implementation of our solver as a two stage process: inference and search. An editor-service specific search strategy determines how and where the search is conducted, and when it terminates. We are currently implementing and evaluating this idea.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684909" title="Get the Full Text from the ACM Digital Library">A symmetry-based n-body solver compiler</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Shigeyuki Sato</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p><i>N</i>-body simulation is a classic application in high-performance computing. Although compiler optimizations designed for other classics such as matrix multiplication and FFT were well developed, the ones designed for <i>N</i>-body problems have been little studied. Hand optimizations for <i>N</i>-body solvers are thus rampant. To remedy this complication, we design a domain-specific language (DSL) embedded in Python for describing <i>N</i>-body problems and develop a DSL compiler that exploits the symmetric nature of <i>N</i>-body problems. It brings efficient code comparably with hand-written code.</p></div> </div>
<h2>SESSION: Doctoral Symposium</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684900" title="Get the Full Text from the ACM Digital Library">Improving performance and quality of database-backed software</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Junwen Yang</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Modern web applications have stringent latency requirements while processing an ever-increasing amount of user data. To address these challenges and improve programmer productivity, Object Relational Mapping (ORM) frameworks have been developed to allow developers writing database processing code in an object-oriented manner. Despite such frameworks, prior work found that developers still struggle in developing ORM-based web applications. This paper presents a series of study and developed tools for optimizing web applications developed using the Ruby on Rails ORM. Using automated static analysis, we detect ORM related inefficiency problems and suggests fixes to developers. Our evaluation on 12 real-world applications shows that more than 1000 performance issues can be detected and fixed.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684901" title="Get the Full Text from the ACM Digital Library">Performance, portability, and productivity for data-parallel applications on multi- and many-core architectures</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Ari Rasch</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>We present a novel approach to performance, portability, and productivity of data-parallel computations on multi- and many-core architectures. Our approach is based on Multi-Dimensional Homomorphisms (MDHs) -- a formally defined class of functions that cover important data-parallel computations, e.g., linear algebra routines (BLAS) and stencil computations. For MDHs, we present a high-level Domain-Specific Language (DSL) that contributes to high user productivity, and we propose a corresponding DSL compiler which automatically generates optimized (auto-tuned) OpenCL code, thereby providing high, portable performance, over different architectures and input sizes, for programs in our DSL. Our experimental results, on Intel CPU and NVIDIA GPU, demonstrate competitive and often significantly better performance of our approach as compared to state-of-practice approaches, e.g., Intel MKL/MKL-DNN and NVIDIA cuBLAS/cuDNN.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684902" title="Get the Full Text from the ACM Digital Library">Practical second Futamura projection: partial evaluation for high-performance language interpreters</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Florian Latifi</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Partial evaluation, based on the first Futamura projection, allows compiling language interpreters with given user programs to efficient target programs. <i>GraalVM</i> is an example system that implements this mechanism. It combines partial evaluation with profiling information and dynamic compilation, to transform interpreters into high-performance machine code at run time. However, partial evaluation is compile-time intensive, as it requires the abstract interpretation of interpreter implementations. Thus, optimizing partial evaluation is still subject to research to this day. We present an approach to speed up partial evaluation, by generating source code ahead of time, which performs partial evaluation specific to interpreter implementations. Generated code, when executed for a given user program at run time, directly emits partially evaluated interpreter instructions for language constructs it knows and sees in the program. This yields the target program faster than performing the first Futamura projection. The generated source code behaves similarly to a specialized partial evaluator deduced by performing the second Futamura projection, although no self-applying partial evaluator is involved during code generation.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684903" title="Get the Full Text from the ACM Digital Library">Retaining semantic information in the static analysis of real-world software</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">G&#225;bor Horv&#225;th</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Static analysis is the analysis of a program through inspection of the source code, usually carried out by an automated tool. One of the greatest challenges posed by real-world applications is that the whole program is rarely available at any point of the analysis process. One reason for this is separate compilation, where the source code of some libraries might not be accessible in order to protect intellectual property. But even if we have a complete view of the source code including the underlying operating system, we might still have trouble fitting the representation of the entire software into memory. Thus, industrial tools need to deal with uncertainty due to the lack of information. </p> <p> In my dissertation I discuss state-of-the-art methods to deal with this uncertainty and attempt to improve upon each method to retain information that would otherwise be unavailable. I also propose guidelines on which methods to choose to solve certain problems.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684904" title="Get the Full Text from the ACM Digital Library">Exploiting models for scalable and high throughput distributed software</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Tim Soethout</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>In high-throughput distributed applications, such as large-scale banking systems, synchronization between objects becomes a bottleneck. This short paper focusses on research, in close collaboration with ING Bank, on the opportunity of leveraging application specific knowledge captured by model driven engineering approaches, to increase application performance in high-contention scenarios, while maintaining functional application-level consistency.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684915" title="Get the Full Text from the ACM Digital Library">Debugging support for multi-paradigm concurrent programs</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Dominik Aumayr</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>With the widespread adoption of concurrent programming, debugging of non-deterministic failures becomes increasingly important. Record & replay debugging aids developers in this effort by reliably reproducing recorded bugs. Because each concurrency model (e.g., threads vs actors) is particularly suited for different tasks, developers started combining them within the same application. Record & replay solutions are typically designed for one concurrency model only. In this paper we propose a novel multi-paradigm record & replay that is based on abstracting concurrency models to a common set of concepts and events.</p></div> </div>
<h2>SESSION: Student Research Competition</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684916" title="Get the Full Text from the ACM Digital Library">Is mutation score a fair metric?</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Beatriz Souza</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Comparing the mutation scores achieved for test suites, one is able to judge which test suite is more effective. However, it is not known if the mutation score is a fair metric to do such comparison. In this paper, we present an empirical study, which compares developer-written and automatically generated test suites in terms of mutation score and in relation to the detection ratios of 7 mutation types. Our results indicate fairness on the mutation score.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684917" title="Get the Full Text from the ACM Digital Library">Designing immersive virtual training environments for experiential learning</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Kalliopi-Evangelia Stavroulia</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Virtual reality (VR) is among the key and most promising emerging technologies in the field of education. The current paper aims to present an innovative VR based approach for teacher education. The development of the VR application followed a full design cycle, with active involvement of education experts during the whole development process. The evaluation results indicate a positive impact of the VR intervention on the cultivation of empathy skills. Moreover, the results are statistically significant related to other parameters under investigation, including the sense of presence, embodiment and user&#8217;s emotional experiences.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684918" title="Get the Full Text from the ACM Digital Library">Linear capabilities for CHERI: an exploration of the design space</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Aaron Lippeveldts</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>CHERI is an instruction set extension that adds capability-based addressing. With capability-based addressing, forgeable pointers are replaced by capabilities. Programs have to be able to show they possess an appropriate capability before they can access a memory location. Linear capabilities are an extension of the idea of regular capabilities. Just like regular capabilities they cannot be forged. Unlike regular capabilities, they additionally cannot be copied or duplicated in any way. Linear capabilities allow us to enforce certain security principles. They can be used to implement a secure calling convention called StkTokens. In this work we will be designing an ISA extension for CHERI so it can support linear capabilities. While doing this, we pose several questions one should consider when designing an extension of this kind, and propose some possible solutions.</p></div> </div> 
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684919" title="Get the Full Text from the ACM Digital Library">An empirical study of programming language effect on open source software development</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Muna Altherwi</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Language designers and early adopters make different claims about their languages to differentiate them from others in order to attract users. Unfortunately, some of such claims are not supported by strong evidence. Moreover, the nature of languages as a <i>special software tool</i> makes it difficult to find objective measures to quantify and compare them <em>per se</em>. One approach to provide objective information about languages is <i>empirical comparison</i>. Hence, this research studies the usage and practice of programming languages based on mining modern, popular, existing software repositories in order to understand and characterize their effect on developing open source software. That is, to compare open source projects written in different languages to understand similarities and examine differences among them.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684910" title="Get the Full Text from the ACM Digital Library">Gradual program analysis</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Samuel Estep</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>The designers of static analyses for null safety often try to reduce the number of false positives reported by the analysis through increased engineering effort, user-provided annotations, and/or weaker soundness guarantees. To produce a null-pointer analysis with little engineering effort, reduced false positives, and strong soundness guarantees in a principled way, we adapt the &#8220;Abstracting Gradual Typing&#8221; framework to the abstract-interpretation based program analysis setting. In particular, a simple static dataflow analysis that relies on user-provided annotations and has nullability lattice <i>N</i> &#8849; &#8868; (where <i>N</i> means &#8220;definitely not null&#8221; and &#8868; means &#8220;possibly null&#8221;) is gradualized producing a new lattice <i>N</i> &#8849; ? &#8849; &#8868;. Question mark explicitly represents &#8220;optimistic uncertainty&#8221; in the analysis itself, supporting a formal soundness property and the &#8220;gradual guarantees&#8221; laid out in the gradual typing literature. We then implement a prototype of our gradual null-pointer analysis as a Facebook Infer checker, and compare it to existing null-pointer analyses via a suite of GitHub repositories used originally by Uber to evaluate their NullAway tool. Our prototype has architecture and output very similar to these existing tools, suggesting the value of applying our approach to more sophisticated program analyses in the future.</p></div> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684911" title="Get the Full Text from the ACM Digital Library">Incremental scannerless generalized LR parsing</a>
</h3>
<ul class="DLauthors">
<li class="nameList Last">Maarten P. Sijm</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>We present the Incremental Scannerless Generalized LR (ISGLR) parsing algorithm, which combines the benefits of Incremental Generalized LR (IGLR) parsing and Scannerless Generalized LR (SGLR) parsing. The parser preprocesses the input by modifying the previously saved parse forest. This allows the input to the parser to be a stream of parse nodes, instead of a stream of characters. Scannerless parsing relies heavily on non-determinism during parsing, negatively impacting the incrementality of ISGLR parsing. We evaluated the ISGLR parsing algorithm using file histories from Git, achieving a speedup of up to 25 times over non-incremental SGLR.</p></div> </div>
<h2>SESSION: Workshop Summary</h2>
<div class="DLabstract"> </div>
<h3>
<a class="DLtitleLink" href="https://dl.acm.org/authorize?N684912" title="Get the Full Text from the ACM Digital Library">Summary of the 17th ACM SIGPLAN international workshop on domain-specific modeling (DSM 2019)</a>
</h3>
<ul class="DLauthors">
<li class="nameList First">Jeff Gray</li>
<li class="nameList">Matti Rossi</li>
<li class="nameList">Jonathan Sprinkle</li>
<li class="nameList Last">Juha-Pekka Tolvanen</li>
</ul>
<div class="DLabstract"><div style="display:inline"><p>Domain-Specific Modeling raises the level of abstraction beyond programming by specifying the solution directly using visual models to express domain concepts. In many cases, final products can be generated automatically from these high-level specifications. This automation is possible because both the language and generators fit the requirements of only one domain. This paper introduces Domain-Specific Modeling and describes the related workshop that took place 20th October 2019.</p></div> </div>
</div>
</div>
</body>
</html>

<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>SOAP 2022: Proceedings of the 11th ACM SIGPLAN International Workshop on the State Of the Art in Program Analysis</title></head><body><div id="DLtoc"><div id="DLheader"><h1>SOAP 2022: Proceedings of the 11th ACM SIGPLAN International Workshop on the State Of the Art in Program Analysis</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3520313"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Papers</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534655">BinFPE: accurate floating-point exception detection for GPU applications</a></h3><ul class="DLauthors"><li class="nameList">Ignacio Laguna</li><li class="nameList">Xinyi Li</li><li class="nameList Last">Ganesh Gopalakrishnan</li></ul><div class="DLabstract"><div style="display:inline">
		<p>When modern heterogeneous HPC systems perform numerical computations, floating-point exceptional quantities such as NaN and infinity in the GPU context, remain insufficiently handled. This is because commonly used GPUs and the CUDA language have no inherent exception detection capabilities. Existing compiler-based approaches for this problem are tied to a given compiler and cannot detect exceptions generated by binaries and precompiled libraries. This paper contributes BinFPE, a unique tool that addresses these challenges. BinFPE uses the NVBit dynamic binary instrumentation framework to check the machine registers after each calculation to recognize exceptions, and conveys this information to the CPU for final reporting. We demonstrate the effectiveness of BinFPE on 42 CUDA programs, reporting previously unreported exceptions. We also present the limitations of BinFPE and our perspective on building GPU tools via binary instrumentation.</p>
	</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534656">Modeling code manipulation in JIT compilers</a></h3><ul class="DLauthors"><li class="nameList">HeuiChan Lim</li><li class="nameList">Xiyu Kang</li><li class="nameList Last">Saumya Debray</li></ul><div class="DLabstract"><div style="display:inline">
		<p>Just-in-Time (JIT) compilers are widely used to improve the  
performance of interpreter-based language implementations  
by creating optimized code at runtime. However, bugs in  
the JIT compiler’s code manipulation and optimization can  
result in the generation of incorrect code. Such bugs can be  
difficult to diagnose and fix, and can result in exploitable  
vulnerabilities. Unfortunately, existing approaches to automatic  
bug localization do not carry over well to such bugs.  
This paper discusses a different approach to analyzing JIT  
compiler optimization behaviors, based on using dynamic  
analysis to construct abstract models of the JIT compiler’s  
optimizer and back end. By comparing the models obtained  
for buggy and non-buggy executions of the JIT compiler, we  
can pinpoint the components of the JIT compiler’s internal  
representation that have been affected by the bug; this can  
then be mapped back to identify the buggy code. Our experiments  
with two real bugs for Google V8 JIT compiler,  
TurboFan, show the utility and practicality of our approach.</p>
	</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534657">Statically detecting data leakages in data science code</a></h3><ul class="DLauthors"><li class="nameList">Pavle Subotić</li><li class="nameList">Uroš Bojanić</li><li class="nameList Last">Milan Stojić</li></ul><div class="DLabstract"><div style="display:inline">
		<p>Data leakage is a well-known problem in machine learning. Data leakage occurs when information from outside the training dataset is used to create a model. This phenomenon renders a model excessively optimistic or even useless in the real world since the model tends to leverage greatly on the unfairly acquired information. To date, detection of data leakages occurs post-mortem using runtime methods. In this paper, we develop a static data leakage analysis to detect several instances of data leakages during development time. Our analysis is constructed to be lightweight so that it can be performed within interactive data science notebooks. We have integrated our analysis into the NBLyzer static analyzer framework and show its utility on real world benchmarks. To the best of our knowledge, we propose the first static detection of data science data leakages.</p>
	</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534658">Ensuring determinism in blockchain software with GoLiSA: an industrial experience report</a></h3><ul class="DLauthors"><li class="nameList">Luca Olivieri</li><li class="nameList">Fabio Tagliaferro</li><li class="nameList">Vincenzo Arceri</li><li class="nameList">Marco Ruaro</li><li class="nameList">Luca Negrini</li><li class="nameList">Agostino Cortesi</li><li class="nameList">Pietro Ferrara</li><li class="nameList">Fausto Spoto</li><li class="nameList Last">Enrico Talin</li></ul><div class="DLabstract"><div style="display:inline">
		<p>Ensuring determinism is mandatory when writing blockchain software.  
When determinism is not met it can lead to serious implications in the blockchain network while compromising the software development, release, and patching processes.  
In the industrial context, it is widespread to adopt general-purpose languages, such as Go, for developing blockchain solutions.  
However, it is not surprising that non-deterministic behaviors may arise, being these programming languages not originally designed for blockchain purposes.  
In this paper, we present an experience report on ensuring determinism in blockchain software with GoLiSA, a static analyzer based on abstract interpretation for Go applications, in an industrial context. In particular, we ran GoLiSA on Commercio.network, a blockchain-based solution for exchanging electronic documents in a legally binding way.  
Thanks to GoLiSA, non-trivial bugs got detected and the analysis performed made it possible to identify the critical points where to apply the fixes.</p>
	</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534659">ADA: a tool for visualizing the architectural overview of open-source repositories</a></h3><ul class="DLauthors"><li class="nameList">Md Rakib Hossain Misu</li><li class="nameList">Aleksandar Saša Janjanin</li><li class="nameList">Zhiqiang Bian</li><li class="nameList">Valentin-Sebastian Burlacu</li><li class="nameList Last">Naum Anteski</li></ul><div class="DLabstract"><div style="display:inline">
		<p>Writing highly maintainable and efficient software code is becoming increasingly difficult, especially while following the rapid, agile development process and working in a distributed team. One of the key indicators of that inefficient software design is a high degree of code coupling, which leads to unwanted side-effects during refactoring and acts as a burden during future development. To alleviate these problems, we developed a visualization tool, ADA, that statically analyzes an open-source repository and seeks to address the issue of code coupling by providing developers with a powerful graphic representation. ADA showcases the relationships and the degree of inter-connectivity between the classes. ADA will ultimately guide developers to instantly locate the coupled area and assist them in decoupling it.</p>
	</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534660">Abstract interpretation of Michelson smart-contracts</a></h3><ul class="DLauthors"><li class="nameList">Guillaume Bau</li><li class="nameList">Antoine Miné</li><li class="nameList">Vincent Botbol</li><li class="nameList Last">Mehdi Bouaziz</li></ul><div class="DLabstract"><div style="display:inline">
		<p>Static analysis of smart-contracts is becoming more widespread  
on blockchain platforms. Analyzers rely on techniques  
like symbolic execution or model checking, but few of them can  
provide strong soundness properties and guarantee the analysis  
termination at the same time. As smart-contracts often  
manipulate economic assets, proving  
numerical properties beyond the absence of runtime errors  
is also desirable. Smart-contract  
execution models differ considerably from mainstream  
programming languages and vary from one blockchain to another,  
making state-of-the-art analyses hard to adapt. For instance,  
smart-contract calls may modify a persistent storage  
impacting subsequent calls. This makes it difficult for tools to  
infer invariants %and high-level security properties  
required to formally ensure the absence of exploitable vulnerabilities.  
</p>
<p>
The Michelson smart-contract language, used in the Tezos  
blockchain, is strongly typed, stack-based, and has a strict  
execution model leaving few opportunities  
for implicit runtime errors. We present a work in progress static analyzer for Michelson  
based on Abstract  
Interpretation and implemented within MOPSA, a modular  
static analyzer.  
Our tool supports the Michelson semantic features, including inner calls to external  
contracts. It can prove the absence of runtime errors and infer  
invariants on the persistent storage over an unbounded number  
of calls. It is also being extended to prove high-level  
numerical and security properties.</p>
	</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3520313.3534661">Towards an implementation of differential dynamic logic in PVS</a></h3><ul class="DLauthors"><li class="nameList">J. Tanner Slagel</li><li class="nameList">César Muñoz</li><li class="nameList">Swee Balachandran</li><li class="nameList">Mariano Moscato</li><li class="nameList">Aaron Dutle</li><li class="nameList">Paolo Masci</li><li class="nameList Last">Lauren White</li></ul><div class="DLabstract"><div style="display:inline">
		<p>This paper describes an ongoing effort to embed and verify differential dynamic logic (dL) in the Prototype Verification System (PVS). dL is a logic for specifying and formally reasoning about <em>hybrid systems</em>, i.e., systems that employ both continuous and discrete dynamics. There are several benefits of this effort. First, the embedding of dL in PVS offers an independent formal verification of the semantics and inference rules of dL. Second, the embedding is fully operational within PVS, giving PVS practitioners the ability to use dL in the formal specification and verification of hybrid systems. Third, the rich specification language, type system, and powerful interactive prover of PVS can be used on dL objects. In addition to the embedding and verification of dL, a custom extension for Visual Studio Code has been developed, so that a stylized dL syntax can be used to specify hybrid programs and their properties.</p>
	</div></div>
							
						</div></div></body></html>
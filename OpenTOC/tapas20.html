<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>TAPAS 2020: Proceedings of the 11th ACM SIGPLAN International Workshop on Tools for Automatic
         Program Analysis
      </title>
   </head>
   <body>
      <div id="DLtoc">
         <div id="DLheader">
            <h1>TAPAS 2020: Proceedings of the 11th ACM SIGPLAN International Workshop on Tools for Automatic
               Program Analysis
            </h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" href="https://dl.acm.org/doi/proceedings/10.1145/3427764"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
               Full Citation in the ACM Digital Library
               </a></div>
         <div id="DLcontent">
            <h2>SESSION: Papers</h2>
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3427764.3428318">API analytics for curating static analysis rules</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Vineeth Kashyap</li>
               <li class="nameList">Roger Scott</li>
               <li class="nameList">Joseph Ranieri</li>
               <li class="nameList">David Melski</li>
               <li class="nameList Last">Lucja Kot</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Use of third-party library APIs is pervasive, but can be error-prone. API-usage errors
                     can be detected via static analysis if specifications of correct usage are available,
                     but manually creating such specifications is a bottleneck. We showcase a semi-automated
                     "big code" solution, where we use large code corpora to mine patterns in API usage,
                     and ask human experts to perform analytics on those patterns to create static analysis
                     rules.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3427764.3428320">MetaCG: annotated call-graphs to facilitate whole-program analysis</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Jan-Patrick Lehr</li>
               <li class="nameList">Alexander Hück</li>
               <li class="nameList">Yannic Fischler</li>
               <li class="nameList Last">Christian Bischof</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>The paper presents the extendable C/C++ whole-program call-graph tool MetaCG. We introduce
                     its graph library, the Clang-based tool CGCollector to construct the call graph and
                     attach meta information, and CGValidate to check for missing edges given a particular
                     execution. MetaCG offers extendability through its metadata function-annotation mechanism
                     to transfer information between tools. It preserves inheritance hierarchies and can
                     be serialized into JSON. We evaluate CG-Collector’s ability to construct whole-program
                     call-graphs for C/C++ code and, subsequently, present a performance profiler and a
                     memory sanitizer that rely on MetaCG for whole-program call-graph information
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3427764.3428322">Online verification of commutativity</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Aditi Kabra</li>
               <li class="nameList">Dietrich Geisler</li>
               <li class="nameList Last">Adrian Sampson</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Systems of transformations arise in many programming systems, such as in graphs of
                     implicit type conversion functions. It is important to ensure that these diagrams
                     commute: that composing any path of transformations from the same source to the same
                     destination yields the same result. However, a straightforward approach to verifying
                     commutativity must contend with cycles, and even so it runs in exponential time. Previous
                     work has shown how to verify commutativity in the special case of acyclic diagrams
                     in <em>O</em>(|<em>V</em>|<sup>4</sup>|<em>E</em>|<sup>2</sup>) time, but this is a <em>batch</em> algorithm: the entire diagram must be known ahead of time. We present an <em>online</em> algorithm that efficiently verifies that a commutative diagram remains commutative
                     when adding a new edge. The new incremental algorithm runs in <em>O</em>(|<em>V</em>|<sup>2</sup>(|<em>E</em>| + |<em>V</em>|)) time. For the case when checking the equality of paths is expensive, we also present
                     an optimization that runs in <em>O</em>(|<em>V</em>|<sup>4</sup>) time but reduces to the minimum possible number of equality checks. We implement
                     the algorithms and compare them to batch baselines, and we demonstrate their practical
                     application in the compiler of a domain-specific language for geometry types. To study
                     the algorithms’ scalability to large diagrams, we apply them to discover discrepancies
                     in currency conversion graphs.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3427764.3428323">Towards checkpoint placement for dynamic memory allocation in intermittent computing</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Nicholas Shoemaker</li>
               <li class="nameList">Ruzica Piskac</li>
               <li class="nameList Last">Mark Santolucito</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Energy harvesting allows computational devices to run without a battery, opening new
                     application domains of computing. Such devices work under an intermittent computing
                     model, where the system may power cycle several times a second. To ensure progress,
                     intermittent computing uses checkpoints, with much work being dedicated to this direction.
                     However, no existing approaches handle programs using dynamically allocated memory
                     in the intermittent computing model. We pose this as a challenge area, demonstrate
                     the complexities of checkpointing in this space, and propose key characteristics of
                     an effective solution.
                  </p>
                  	
               </div>
            </div>
            						
            					
            						
            <h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" href="https://dl.acm.org/doi/10.1145/3427764.3428324">Type checking beyond type checkers, via slice &amp; run</a></h3>
            <ul class="DLauthors">
               <li class="nameList">Justus Adam</li>
               <li class="nameList Last">Stephen Kell</li>
            </ul>
            <div class="DLabstract">
               <div style="display:inline">
                  		
                  <p>Type checkers are the most commonly used form of static analysis, but their design
                     is coupled to the rest of the language, making it hard or impossible to bring new
                     kinds of reasoning to existing, unmodified code. We propose a novel approach to checking
                     advanced type invariants and properties in unmodified source code, while approaching
                     the speed and ease of simple, syntax directed type checkers. 
                  </p> 
                  <p> The insight is that by combining a deep program analysis (symbolic execution) with
                     a cheaper program abstraction (based on program slicing), it appears possible to reconstitute
                     type-checking in the context of an underapproximate analysis. When the program's 'type
                     level' can be opportunistically disentangled from the 'value level', this is done
                     by the program abstraction step, in some cases removing the underapproximation. 
                  </p> 
                  <p> We implement a simple prototype that demonstrates this idea by checking the safety
                     of generic pointers in C, pointing to benefits such as safe homogeneous and heterogeneous
                     generic data structures.
                  </p>
                  	
               </div>
            </div>
            						
            					
         </div>
      </div>
   </body>
</html>
<html xmlns:bkstg="http://www.atypon.com/backstage-ns" xmlns:urlutil="java:com.atypon.literatum.customization.UrlUtil" xmlns:pxje="java:com.atypon.frontend.services.impl.PassportXslJavaExtentions"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="Content-Style-Type" content="text/css"><style type="text/css">
            #DLtoc {
            font: normal 12px/1.5em Arial, Helvetica, sans-serif;
            }

            #DLheader {
            }
            #DLheader h1 {
            font-size:16px;
            }

            #DLcontent {
            font-size:12px;
            }
            #DLcontent h2 {
            font-size:14px;
            margin-bottom:5px;
            }
            #DLcontent h3 {
            font-size:12px;
            padding-left:20px;
            margin-bottom:0px;
            }

            #DLcontent ul{
            margin-top:0px;
            margin-bottom:0px;
            }

            .DLauthors li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLauthors li:after{
            content:",";
            }
            .DLauthors li.nameList.Last:after{
            content:"";
            }

            .DLabstract {
            padding-left:40px;
            padding-right:20px;
            display:block;
            }

            .DLformats li{
            display: inline;
            list-style-type: none;
            padding-right: 5px;
            }

            .DLformats li:after{
            content:",";
            }
            .DLformats li.formatList.Last:after{
            content:"";
            }

            .DLlogo {
            vertical-align:middle;
            padding-right:5px;
            border:none;
            }

            .DLcitLink {
            margin-left:20px;
            }

            .DLtitleLink {
            margin-left:20px;
            }

            .DLotherLink {
            margin-left:0px;
            }

        </style><title>SPLASH Companion '24: Companion Proceedings of the 2024 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity</title></head><body><div id="DLtoc"><div id="DLheader"><h1>SPLASH Companion '24: Companion Proceedings of the 2024 ACM SIGPLAN International Conference on Systems, Programming, Languages, and Applications: Software for Humanity</h1><a class="DLcitLink" title="Go to the ACM Digital Library for additional information about this proceeding" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/proceedings/10.1145/3689491"><img class="DLlogo" alt="Digital Library logo" height="30" src="https://dl.acm.org/specs/products/acm/releasedAssets/images/footer-logo1.png">
                Full Citation in the ACM Digital Library
            </a></div><div id="DLcontent"><h2>SESSION: Keynotes</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3700407">Everything Is a Program (Even If It's Not) (Keynote)</a></h3><ul class="DLauthors"><li class="nameList Last">Todd Millstein</li></ul><div class="DLabstract"><div style="display:inline">
				<p>A brief discussion at a conference more than 15 years ago led to a collaborative research agenda that has been incredibly fun, intellectually challenging, and impactful. Internet protocols like BGP and DNS underlie everything that we do online, but they routinely break network security and reliability due to their complexity and fragility. While there are many moving parts and underlying causes, time and again the programming languages perspective has proven to be a powerful way to make progress. In short, everything is a program (even if it’s not), and once something is a program we can give it a precise semantics and bring to bear a host of techniques to reason about its behavior. I’ll illustrate this approach through examples from my work, but the ideas are applicable beyond computer networks. I’ll also distill some general lessons that I’ve learned about doing collaborative research and making an impact.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3700408">AI: Winter of Our Discontent (Keynote)</a></h3><ul class="DLauthors"><li class="nameList Last">Richard P. Gabriel</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In his keynote address on AI Winter, Richard P. Gabriel delves into the recurring cycles of high expectations and subsequent disappointments in the field of artificial intelligence. He posits that AI, unlike other computer science problems, has goals that are easily understood yet inherently vague, akin to the subjective nature of success in artistic endeavors such as painting, writing, and music. Gabriel critiques the limitations of large language models (LLMs), noting that they lack the human ability to handle novel situations and discover new information, being constrained to knowledge acquired during training. He suggests that the comprehensive training of LLMs across all perspectives prevents them from developing a unique point of view, which could be detrimental to their creative capabilities. Gabriel provocatively speculates that a more limited, less knowledgeable LLM might better emulate human writers, learning to forget and thereby fostering a more genuine form of creativity.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3700409">Trillions of Formally Verified Authorizations a Day! (Keynote)</a></h3><ul class="DLauthors"><li class="nameList Last">Neha Rungta</li></ul><div class="DLabstract"><div style="display:inline">
				<p>To control access to their data and resources, AWS users write policies that express fine-grained permissions. An authorization engine evaluates these policies trillions of times a day to determine if access is allowed. The authorization engine is a critical part of the security, availability, and correctness of AWS. To raise the bar in the security and correctness of this engine, we replaced it with a formally verified one. It was absolutely critical that users were not impacted by the change. Over a period of months and over quadrillion tests, we gathered data on the impact, and deployed the new verified engine. And then what happens? Come to the talk to find out.</p>
			</div></div>
							
						<h2>SESSION: Doctoral Symposium</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691814">Unified Analysis Techniques for Programs with Outcomes</a></h3><ul class="DLauthors"><li class="nameList Last">Noam Zilberstein</li></ul><div class="DLabstract"><div style="display:inline">
				<p>The theories required for program analysis have evolved past the foundations developed decades ago.
 
 
 
Programs display computational effects such as nondeterminism, randomization, exceptions, and mutable state.
 
 
 
Orthogonally, bug-finding is often more tangible than establishing correctness.
 
 
 
Specialized techniques have been introduced to handle effects and incorrectness reasoning.
 
 
 
While successful, the disjointed nature of those techniques means that new analysis systems must be built to analyze each kind of program and property. 
 
 
 
In my research, I am creating a logical foundation to consolidate the aforementioned theories, with which I plan to develop a new generation of static analysis tools that are simpler and more efficient than those available today.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691816">A VM-Based Approach for Power Modeling</a></h3><ul class="DLauthors"><li class="nameList Last">Joseph Raskind</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Power modeling is an essential building block for computer systems in support of energy optimization, energy profiling, and energy-aware application development. In 2024, I introduced VESTA, a novel approach to modeling the power consumption of applications with one key insight: language runtime events are often correlated with a sustained level of power consumption. When compared with the established approach of power modeling based on hardware performance counters (HPCs), VESTA has the benefit of solely requiring application-scoped information and enabling a higher level of explainability, while achieving comparable or even higher precision. I hope to continue on this track of discovering the deep connections between VM-events and power consumption while also providing practical solutions for mapping one to the other through the construction of power models.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691817">Full-Stack Collaboration for Robust Heterogeneity-Enabled AI Systems</a></h3><ul class="DLauthors"><li class="nameList Last">Yuxin Qiu</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In this new era of AI with diverse hardware accelerators such as GPUs and quantum circuits, achieving system-wide robustness requires tackling issues throughout all system layers, spanning from software applications to hardware components. My research is to enhance the robustness of heterogeneity-enabled AI systems by reinventing software testing and analysis techniques via leveraging full-stack insights and advanced AI capabilities. I have completed one research project and have collaborated on a couple of others at the application and language levels. As the next steps, I will explore (1) holistic regression testing to prioritize test inputs associated with system-wide changes and (2) full-stack analysis to optimize computing resource allocation and reduce hardware reliance by analyzing application characteristics and using alternative resources in tandem.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691819">JMVX: Improving Record-Replay for Managed Languages</a></h3><ul class="DLauthors"><li class="nameList Last">David Schwartz</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Record-Replay (RR) is a useful technique for investigating concurrency related bugs whose appearance are subject to particular thread schedulings. RR logs/records the nondeterministic inputs that influence a program such as thread scheduling, shared memory operations, and external file/socket data. The recording can be replayed, providing the same inputs to replicate the bug. Unfortunately, RR is not good at patch validation. Mutable replay is when a recording generated by the buggy version of a program is replayed on the patched version. Patches typically introduce divergent behavior which often prevents replay entirely.
 

 
In addition, current RR systems are slow for languages running on a Virtual Machine like Java. They limit parallelism while forcing the Garbage Collector and Just-In-Time compiler to behave eactly the same between the recording and replay. RR systems designed for Java replay mulithreaded code incorrectly or require the use of a customized JVM.
 

 
To alleviate this, we developed a prototype RR system for Java called JMVX. It operates within Java bytecode, allowing it to tolerate benign divergences --- differences in a program's execution caused by functionally equivalent operations introduced by the garbage collector, just in time compiler, and class loading. JMVX supports multithreaded replay by providing a total ordering of monitor/lock operations via a vector clock. JMVX will serve as a foundation to experiment with partial order implementations of the vector clock and specialized support for thread pools. In addition, we plan to support mutable replay by allowing the replay to interact "live" with a mock version of a resource's snapshot.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691820">Static-Dynamic Information Flow Control in Rust</a></h3><ul class="DLauthors"><li class="nameList Last">Vincent Beardsley</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Information Flow Control (IFC) provides security by preventing high-secrecy data from flowing to low-secrecy data, and low-integrity data from flowing to high-integrity data. However, prior approaches to IFC either suffer from imprecision and falsely identify security violations, or require modification of the programming language or compiler, reducing the practical utility for programmers. Recent work Cocoon demonstrates an approach to IFC that allows for precision without modifying the language or compiler, but is severely limited in its practical use by virtue of only supporting IFC for static secrecy. I have created an IFC approach called Carapace that adds support for both integrity and dynamic labels.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691821">Step-wise Execution of Data-Centric Systems</a></h3><ul class="DLauthors"><li class="nameList Last">Chi Zhang</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Data-centric systems play a crucial role in computer systems, and their correctness is of paramount importance. Logic bugs are one of the main types of bugs in data-centric systems, leading to incorrect results. Existing methods for testing data-centric systems face challenges such as ineffective test oracles, insufficient coverage of target functionalities, and low efficiency in test case generation. To address these issues, we propose a general, novel black-box methodology for testing various kinds of important data-centric systems. Our key insight is that we can incrementally generate the test case and use the intermediate results to construct the reference test case. The result of the original test case should be identical to that of the reference test case. We have applied this methodology to test both Datalog engines and DBMSs, successfully uncovering 75 unique bugs. We believe that this idea might be applicable to many other systems as well, and will next explore this idea to Deep Learning libraries.</p>
			</div></div>
							
						<h2>SESSION: Student Research Competition</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689966">A Parameterized Framework for the Formal Verification of Zero-Knowledge Virtual Machines</a></h3><ul class="DLauthors"><li class="nameList Last">Youwei Zhong</li></ul><div class="DLabstract"><div style="display:inline">
				<p><em>Zero-knowledge virtual machine</em>s (<em>zkVM</em>s) enable verifiable computation on via succinct <em>Zero-knowledge proof</em>s (<em>ZKP</em>s). However, current zkVMs, still in development, show many bugs. This paper introduces a parameterized framework for the formal verification of zkVMs in Coq. We prove the soundness and completeness of the constraint generation algorithm from machine instructions to semantics-level constraints. Existing works target specific zkVMs, and require repeated proof work in this phase, whereas our proofs are parameterized and can be reused in development and by all zkVMs. We also demonstrate the generality of our framework by instantiation on two examples: Cairo VM and a simplified zkEVM.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689967">Algebraic Effect Handlers with Bidirectional Type-Checking</a></h3><ul class="DLauthors"><li class="nameList Last">Maya Mückenschnabel</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In the development of type systems there are multiple paths for achieving more expressiveness. On the one hand, algebraic effect handlers allow us to reason about program’s side effects. On the other hand, dependent types make it possible to more precisely reason about program states and data and to prove general mathematical statements. We propose a new type system based on bidirectional type-checking for algebraic effects handlers and dependent types.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689968">Automatically Generating an Abstract Interpretation-Based Optimizer from a DSL</a></h3><ul class="DLauthors"><li class="nameList Last">Ken Jin Ooi</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Just-in-Time (JIT) compilers can gain information at run time that are not available to Ahead-of-Time (AOT) compilers. As such, abstract interpretation baseline JIT compilers are common in many dynamic language implementations. Yet the reference implementation of Python --- CPython, has largely avoided implementing a baseline JIT compiler, likely due to the prohibitive maintenance costs associated with one. This paper implements an abstract-interpretation based optimizer for CPython bytecode that is easy to maintain and less error-prone by automatically generating the optimizer from a pre-existing Domain Specific Language (DSL) --- reusing the same DSL used to specify the interpreter. The key insight presented in this paper is that the very same DSL used to generate a concrete interpreter can also generate an abstract interpreter, providing multiple benefits such as being less error-prone and greater extensibility. The proposed abstract interpreter has been accepted into CPython 3.13 and forms a part of its experimental JIT compiler.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689969">A Formal Approach to the Analysis of Human-Machine Interaction with Fuzzy Logic</a></h3><ul class="DLauthors"><li class="nameList Last">Leyi Cui</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Human uses mental models when interacting with systems. Misalignment between a mental model and the system design, known as mode confusions, can lead to automation surprises. To better handle the vagueness of mental models through formalization, Fuzzy Mental Model Finite State Machines (FMMs), incorporating fuzzy logic, have been introduced. This work explores the potential of FMMs in formal analyses of human-machine interactions, proposing a set of formal behavior patterns of mode confusions and a tool for identifying mode confusions and unsafe interactions.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689970">Automatic Local Inverse Calculation for Change of Variables</a></h3><ul class="DLauthors"><li class="nameList Last">Elias Rojas Collins</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Inversion is a fundamental operation that arises frequently in probabilistic inference and computer graphics.         For example, inversion is used to decrease variance and to enable differentiation in variational inference (e.g., reparameterization trick) and in differentiable rendering (e.g., to integrate over object boundaries).        Existing approaches to inversion limit the class of functions inverted, for example, to affine functions, or require a user-specified inverse.        We study when a <em>local inverse</em>—an inverse that is valid in a neighborhood of a point—exists. We provide an algorithm to approximate the local inverse and give the convergence rate of the solver.        We present LIN, a system that automatically computes the local inverse of a function using a fixed-point solver.        We implement LIN in Python and use it to automatically compute the local inverse of affine, polar, and hyperbolic changes of variables arising in image stylization.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689971">Kawa: An Abstract Language for Scalable and Variable Detection of Spectre Vulnerabilities</a></h3><ul class="DLauthors"><li class="nameList">Zheyuan Wu</li><li class="nameList">Haoyi Zeng</li><li class="nameList Last">Aaron Bies</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Since the discovery of Spectre attacks, various detection methods for speculative vulnerabilities have been developed. Sound static analyses based on symbolic execution give precise results but lack scalability, while pattern-based analyses can accommodate large code bases but may be unsound and require manually crafted patterns for each microarchitecture.
 

 
We introduce Kawa, an abstract language designed to model control and data flows, allowing efficient analysis of Spectre vulnerabilities. Kawa's abstract nature also enables interpretation as schemata to capture entire classes of concrete programs with speculative leaks.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689972">Design of Fractional Permissions for a Gradual Verifier</a></h3><ul class="DLauthors"><li class="nameList Last">Craig Liu</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Static verification assures program correctness but requires heavy user annotation. Gradual verification alleviates this burden by allowing users to write partial, imprecise specifications that are checked statically where possible and dynamically when necessary. The first gradual verifier, Gradual C0, reasons about shared heap memory through a permission logic. This paper describes an extension to Gradual C0 which supports fractional permissions in its permission logic.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689977">Grammar Derivation Visualization in Automata Theory</a></h3><ul class="DLauthors"><li class="nameList">Tijana Minić</li><li class="nameList Last">Andrés M. Garced</li></ul><div class="DLabstract"><div style="display:inline">
				<p>In Formal Languages and Automata Theory courses, students are exposed to grammars. They are expected to learn how to design them and how to use them to derive words in the grammar’s language. Some students, however, find understanding word derivation difficult due to nondeterminism and find it difficult to determine if the grammars they develop are correct. This research project aims to develop novel visualization tools to help students understand grammar derivation and establish the correctness of their designs.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689974">VESC: Towards Temporal Verification of Smart Contracts</a></h3><ul class="DLauthors"><li class="nameList">Samuel Larsen</li><li class="nameList">Kevin Johanson</li><li class="nameList Last">Yuandong Cyrus Liu</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Blockchain technologies are applied in diverse domains such as financial systems, supply chains, and identity management, leading to the emergence of various smart contract languages design. These contracts often involve time dependent transactions recorded immutably on the blockchain, making their correctness crucial. This paper addresses the formal verification of temporal behaviors in smart contracts without human interaction. We study 9 recent smart contract languages used in 7 leading blockchains and model 27 common temporal patterns from 3148 benchmarks across 9 domain specific application categories. We introduce VESC, a temporal specification language that allows developers to specify temporal properties in structured natural language, which VESC compiles into formal linear temporal logic. Our experiments demonstrate that VESC effectively specifies common temporal behaviors, paving the way for automated temporal verification of smart contracts.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3689975">Understanding Program Visualizations in the Wild</a></h3><ul class="DLauthors"><li class="nameList">Joel Enrique Castro Hernandez</li><li class="nameList Last">Olohi Goodness John</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Visualizations play a significant role in writing, debugging, profiling, and generally understanding programs. However, little work has been done to understand the structure of program visualizations at a fundamental level— namely, why and how they <em>scale</em>. Previous work on visualization comprehension focuses narrowly on a few domains or on surface-level details. While this work makes it possible to point out <em>how</em> different features of two vastly different visualizations may be independently effective, it does not provide an underlying theory that explains both. We develop a theory of the interpretability of program visualizations focused on their abstraction and composition properties. We summarize the preliminary results from our grounded theory study of open-source software visualizations, comprising more than 150 examples. Finally, we hint at work-in-progress to experimentally confirm our findings.</p>
			</div></div>
							
						<h2>SESSION: Posters</h2>
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691822">Meerkat: Distributed Reactive Live Semantics with Causal Consistency</a></h3><ul class="DLauthors"><li class="nameList">Heng Zhong</li><li class="nameList Last">Anrui Liu</li></ul><div class="DLabstract"><div style="display:inline">
				<p>We introduce Meerkat, a novel, type-safe reactive programming language supporting concurrent live code updates in distributed scenarios. Meerkat seamlessly integrates the development of both server-side and client-side components within a unified framework. The language ensures causal consistency during data updates through the Historiographer algorithm. The soundness of concurrent code updates is maintained by a type-checking process protected by our locking protocol.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691823">Ordering Rejectable Stacks in SGLR Parsing</a></h3><ul class="DLauthors"><li class="nameList">Jeff Smits</li><li class="nameList Last">Daniel A. A. Pelsmaeker</li></ul><div class="DLabstract"><div style="display:inline">
				<p>Scannerless Generalised LR can parse context-free grammars extended with conjunction-with-negation, represented by <em>reject</em> rules. To handle reject rules correctly, Visser defines a specific ordering between states that can be reduced during parsing: first reduce non-rejectable states, then rejectable states. However, he remarks that in specific situations an ordering <em>between</em> rejectable states is required for correct parsing results, for example when encoding intersections with reject rules. The question of how to order rejectable states was left open. In this work, we present a solution that orders <em>stacks</em> topped by rejectable states.</p>
			</div></div>
							
						
							<h3><a class="DLtitleLink" title="Full Citation in the ACM Digital Library" referrerpolicy="no-referrer-when-downgrade" href="https://dl.acm.org/doi/10.1145/3689491.3691824">AUTOINC: Incrementality for Free</a></h3><ul class="DLauthors"><li class="nameList">André Pacak</li><li class="nameList">Prashant Kumar</li><li class="nameList">Runqing Xu</li><li class="nameList Last">Sebastian Erdweg</li></ul><div class="DLabstract"><div style="display:inline">
				<p>We present the new project called AUTOINC, which aims to automatically incrementalize general-purpose computations.</p>
			</div></div>
							
						</div></div></body></html>